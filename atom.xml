<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kardel的希尔伯特空间</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://ChenKardel.github.io/"/>
  <updated>2018-06-18T08:50:31.612Z</updated>
  <id>http://ChenKardel.github.io/</id>
  
  <author>
    <name>kardel</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据库复习</title>
    <link href="http://ChenKardel.github.io/2018/06/18/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0/"/>
    <id>http://ChenKardel.github.io/2018/06/18/数据库复习/</id>
    <published>2018-06-18T08:45:20.000Z</published>
    <updated>2018-06-18T08:50:31.612Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库复习"><a href="#数据库复习" class="headerlink" title="数据库复习"></a>数据库复习</h1><h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>注：定义性质的我都用<em>斜体</em> 标注</p><h3 id="数据库系统的特点和概念"><a href="#数据库系统的特点和概念" class="headerlink" title="数据库系统的特点和概念"></a>数据库系统的特点和概念</h3><h4 id="三层模式"><a href="#三层模式" class="headerlink" title="三层模式"></a>三层模式</h4><p>三层模式是指ANSI-SPARC体系结构</p><p><em>三层体系结构指的是外部层、概念层和内部层</em> </p><p>外部层提供视图，提供用户观察数据的视图</p><p>概念层提供内、外部层的映射和必要的独立性</p><p>内部层提供DBMS和操作系统观察和存储数据的结构。</p><h5 id="三层模式的优点："><a href="#三层模式的优点：" class="headerlink" title="三层模式的优点："></a>三层模式的优点：</h5><ol><li>每个用户都可以操作自己的数据视图而不影响其他用户</li><li>将数据库物理存储的细节隔离出来</li><li>DBA能够在不影响用户视图的情况下修改数据库存储结构</li><li>数据库的内部结构不受存储的物理变化的影响</li></ol><h5 id="外部层"><a href="#外部层" class="headerlink" title="外部层"></a>外部层</h5><p><em>外部层是数据库的用户视图，这一层描述了每一个用户相关的数据库部分</em> </p><p>外部层由数据库中的若干个不同视图组成。每个用户都有自己的视图，该视图用其最熟悉的方式表示现实世界</p><h5 id="概念层"><a href="#概念层" class="headerlink" title="概念层"></a>概念层</h5><p><em>概念层是数据库的整体视图。这一层描述了哪些数据被存储在数据库中，以及这些数据之间的联系</em></p><p>比如：</p><ul><li>所有实体、实体的属性和实体间的联系‘</li><li>数据的约束</li><li>数据的语义信息</li><li>安全性和完整性信息</li></ul><p>概念层支持每一个外部视图，凡是用户可以访问的数据必定包含在概念层或者由概念层数据可导出。</p><h5 id="内部层"><a href="#内部层" class="headerlink" title="内部层"></a>内部层</h5><p><em>内部层是数据库在计算机上的物理表示。这一层描述数据是如何存储在数据库中。</em></p><p>内部层包括为了得到数据库运行时的最佳性能而采用的物理实现方法</p><p>内部层与如下工作相关：</p><ul><li>数据和索引的存储空间分配</li><li>用于存储的记录描述（数据项的存储大小）</li><li>记录放置</li><li>数据压缩和数据加密技术</li></ul><p>内部层之下是物理层，物理层可能在DBMS的指导下受操作系统的控制。</p><h4 id="DB-DBMS-DBS"><a href="#DB-DBMS-DBS" class="headerlink" title="DB/DBMS/DBS"></a>DB/DBMS/DBS</h4><h5 id="DB"><a href="#DB" class="headerlink" title="DB"></a>DB</h5><p><em>为满足某个组织机构的信息要求而设计的一个逻辑相关数据及其描述的共享集</em></p><p>逻辑相关数据：包含实体，属性，组织机构信息的关系</p><p>系统目录（元数据）：提供数据的描述去使数据与程序独立</p><h5 id="DBMS"><a href="#DBMS" class="headerlink" title="DBMS"></a>DBMS</h5><p><em>一个支持用户对数据库进行定义、创建、维护及控制访问的软件系统</em></p><p>提供以下功能：</p><ol><li>数据定义语言（DDL）</li><li>数据控制语言（DML）</li><li>数据库的受控访问</li></ol><h5 id="DBS"><a href="#DBS" class="headerlink" title="DBS"></a>DBS</h5><p>数据库系统由</p><ol><li>DB：一个特定于应用程序的数据库</li><li>DBMS：一个可以使用户定义，创造，维护，控制数据库访问权限的软件系统</li><li>AP：控制数据库的应用程序</li></ol><h3 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h3><h4 id="对象关系模型"><a href="#对象关系模型" class="headerlink" title="对象关系模型"></a>对象关系模型</h4><p><em>一个描述数据、数据间的关系，约束的集成集合</em></p><h4 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h4><p>关系：关系是由行和列组成的表</p><p>属性：属性是关系中命名的列</p><p>域：域是一个或多个属性的取值集合</p><p>元组：关系中的每一行称为元组</p><p>维数：关系的维数是指关系所包含属性的个数（不严谨的说就是列数）</p><p>基数：关系的基数是指它所包含的元组的个数</p><p>（不严谨的说就是行数）</p><p>关系数据库：关系数据库是具有不同关系名的规范化关系的集合</p><p>关系模式：用一组属性和域名对定义的具名的关系，比如$$(A_1:d_1, A_2:d_2,…, A_n:d_n)，其中d1\in D_1, d_2\in D_2, …, d_n\in D_n$$</p><p>$A_i$是属性，$d_i$是值，$D_i$是域</p><h4 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h4><h5 id="超关键字"><a href="#超关键字" class="headerlink" title="超关键字"></a>超关键字</h5><p><em>一个属性或属性集合，它能唯一地表示出关系中每个元组</em></p><h5 id="候选关键字"><a href="#候选关键字" class="headerlink" title="候选关键字"></a>候选关键字</h5><p><em>本身就是超关键字但其任何子集都不再是超关键字</em></p><h5 id="主关键字"><a href="#主关键字" class="headerlink" title="主关键字"></a>主关键字</h5><p><em>被选用于唯一表示关系中各元组的候选关键字</em></p><p>实际上就相当于NOT NULL + UNIQUE</p><h5 id="可替换关键字"><a href="#可替换关键字" class="headerlink" title="可替换关键字"></a>可替换关键字</h5><p><em>没有被选于唯一标识关系中各元组的候选关键字</em></p><h5 id="外部关键字"><a href="#外部关键字" class="headerlink" title="外部关键字"></a>外部关键字</h5><p><em>当一个关系中的某个属性或属性集合域另一个关系的候选关键字匹配时，就称这个属性或属性集合为外部关键字</em></p><h4 id="完整性约束"><a href="#完整性约束" class="headerlink" title="完整性约束"></a>完整性约束</h4><h5 id="实体完整性"><a href="#实体完整性" class="headerlink" title="实体完整性"></a>实体完整性</h5><p><em>在基本关系中，主关键字属性不能为空</em> </p><h5 id="引用完整性"><a href="#引用完整性" class="headerlink" title="引用完整性"></a>引用完整性</h5><p><em>如果在关系中存在某个外部关键字，则它的值与主关系中某个元组的<strong>候选关键字</strong>取值相等，或者全为空</em></p><p>注意一定是候选关键字而不是一般属性</p><h4 id="运算操作"><a href="#运算操作" class="headerlink" title="运算操作"></a>运算操作</h4><p>八运算操作，其中五个基本运算操作</p><ol><li>集合并</li><li>集合差</li><li>笛卡尔集</li><li>选择</li><li>投影</li></ol><p>其余三个</p><ol start="6"><li>连接</li><li>集合交</li><li>除<br>注意一下他们的符号</li></ol><p>#####选择：$\sigma$</p><p>选择工资多余10000的员工：$\sigma_{salary&gt;1000}(Staff)$</p><h5 id="投影：-Pi"><a href="#投影：-Pi" class="headerlink" title="投影：$\Pi$"></a>投影：$\Pi$</h5><p>选出员工的staffNo，fName，lName，salary: </p><p>$\Pi_{staffNo, fName, lName, salary}(Staff)$</p><h5 id="并：-cup"><a href="#并：-cup" class="headerlink" title="并：$\cup$"></a>并：$\cup$</h5><p>$\Pi_{city}(Branch) \cup \Pi_{city}（PropertyForRent）$</p><h5 id="差："><a href="#差：" class="headerlink" title="差：$-$"></a>差：$-$</h5><p>$\Pi_{city}(Branch) - \Pi_{city}（PropertyForRent）$</p><h5 id="交：-cap"><a href="#交：-cap" class="headerlink" title="交：$\cap$"></a>交：$\cap$</h5><p>$\Pi_{city}(Branch) \cap \Pi_{city}（PropertyForRent）$</p><h5 id="笛卡尔集：-times"><a href="#笛卡尔集：-times" class="headerlink" title="笛卡尔集：$\times$"></a>笛卡尔集：$\times$</h5><p>$\Pi_{clientNo, fName, lName}(Client) \times \Pi_{clientNo, propertyNo, comment}（Viewing）$</p><p>注意两点</p><ol><li><p>如果两个表中有相同的属性，则应该用表名唯一表示</p><p>用书上的例子</p></li></ol><table><thead><tr><th>client.clientNo</th><th>fName</th><th>lName</th><th>Viewing.clientNo</th><th>propertyNo</th><th>comment</th></tr></thead><tbody><tr><td>…</td><td>…</td><td>…</td><td>…</td><td>…</td><td>…</td></tr></tbody></table><p>   其中Client表和View表都有clientNo这个属性（具体什么意思不用管了）</p><p>   但是为了唯一标识，要把表名列出来</p><ol start="2"><li><p>这个笛卡尔集使任意交叉，没有经过筛选，要筛选需要再用次选择</p><p>$\sigma_{Client.clientNo = Viewing.clientNo}(\Pi_{clientNo, fName, lName}(Client) \times \Pi_{clientNo, propertyNo, comment}（Viewing)$</p></li></ol><h5 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h5><p>连接有很多种</p><ol><li><p>$\theta$连接</p><p>$\theta$连接时最简单的连接</p><p>$R\Join_{F}S = \sigma_{F}(R \times S)$</p><p>带谓语的连接</p></li><li><p>自然连接</p><p>自然连接是在公共属性上连接，</p><p>在上面的例子上可以是</p><p>$$\Pi_{client.clientNo, fName, lName, propertyNo, comment}(\sigma_{Client.clientNo = Viewing.clientNo}(\Pi_{clientNo, fName, lName}(Client) \times \Pi_{clientNo, propertyNo, comment}（Viewing))$$</p></li><li><p>外连接</p><p>外连接是两张表，展示一张表所有内容，如果另一张表没有对应内容，则填null。</p><p>左外连接：$\ltimes$ </p><p>右外连接：$\rtimes$</p><p>开口指向展示所有内容的一边    </p></li><li><p>半连接算了吧</p></li></ol><h5 id="除法运算"><a href="#除法运算" class="headerlink" title="除法运算"></a>除法运算</h5><p>除法运算问题很大</p><p>我觉得除法运算和分组有点像</p><p>具体可以看</p><p><a href="https://blog.csdn.net/t_1007/article/details/53036082" target="_blank" rel="noopener">关系代数中的除法运算</a></p><p>例如$R\div S$</p><p>R(X, Y)，S(Y, F)</p><ol><li>找到R,S两个集合公共属性Y</li><li>对着除的集合（右边的）S找它的Y，对每一个Y中的元素找被除的集合（左边的）R的X</li><li>如果S对给定的Y的X都是一样的，加入结果集，否则不加入</li><li>获取结果集</li></ol><p>PS：说不清楚啊……</p><p>除此之外，还可以提一下分组运算，但不如后面的SQL种讲</p><h3 id="SQL语言"><a href="#SQL语言" class="headerlink" title="SQL语言"></a>SQL语言</h3><p>Structured Query Language</p><p>SQL是DDL、DML、DQL、DCL的集成（扯什么犊子，都一箩筐）</p><p>SQL 不区分大小写</p><p>####DDL</p><p>数据定义语言（Data Definition Language，DDL）用于定义数据库结构和数据的访问控制</p><p>几个命令</p><ul><li>CREATE</li><li>ALTER</li><li>DROP</li><li>TRUNCATE</li><li>GRANT</li><li>REVOKE</li></ul><h4 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h4><p>数据操作语言（Data Manipulation Language，DML）用于检索和更新数据</p><p>几个命令</p><ul><li>SELECT</li><li>DELETE</li><li>UPDATE</li><li>INSERT</li><li>CALL(调用PLSQL那货)</li><li>LOCK  TABLE</li></ul><h4 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a>DCL</h4><p>数据控制语言（Data Control Language，DCL），用来授予或回收访问数据库的某种特权，并控制数据库操纵事务发生的时间及效果，对数据库实行监视等</p><ul><li>COMMIT</li><li>SAVEPOINT</li><li>ROLLBACK</li><li>SET TRASACTION</li></ul><p>处理事务用</p><p><a href="https://www.2cto.com/database/201610/555167.html" target="_blank" rel="noopener">DDL、DML和DCL的区别与理解</a> </p><p>不具体讲，注意几个小点</p><ol><li><p>SELECT DISTINCT * 语序不要搞反</p></li><li><p>LIKE的%是0个或多个，_是一个</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LIKE 'Hel__ %d'</span><br></pre></td></tr></table></figure><p>当然我隐约记得Sql lite支持^和$，</p><p>也可以使用NOT LIKE表示不遵循表达式数据项</p></li><li><p>在where中，如果对另一张表的查询结果只有一个，可以用=的，如果有多个，用<code>IN</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> STUDENT <span class="keyword">WHERE</span> STUDENTID = (<span class="keyword">SELECT</span> STUDENTID <span class="keyword">FROM</span> TEACHER)</span><br><span class="line"><span class="comment">-- 确保后面的查询只有一个结果（假设是一对一老师教学（滑稽））</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> TEACHER <span class="keyword">WHERE</span> TEACHERID <span class="keyword">IN</span> (<span class="keyword">SELECT</span> TEACHERID <span class="keyword">FROM</span> STUDENT)</span><br><span class="line"><span class="comment">-- 当后面查询结果有多个的时候</span></span><br></pre></td></tr></table></figure></li><li><p>GROUP</p><p>GROUP BY的意思是将GROUP BY后面的属性相同的列并起来，并且呈现</p><p>SELECT中只有GROUP BY后面的属性可以被SELECT，其他都得被聚合函数聚合</p><p>GROUP中的约束用HAVING，HAVING中操作的属性在GROUP BY<strong>可以</strong>呈现的属性集合中</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> branchNo, <span class="keyword">COUNT</span>(staffNo) <span class="keyword">AS</span> myCount, <span class="keyword">SUM</span>(salary) <span class="keyword">AS</span> mySum</span><br><span class="line"><span class="keyword">FROM</span> Staff</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> branchNo</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(staffNo) &gt; <span class="number">1</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> branchNo;</span><br></pre></td></tr></table></figure></li><li><p>老生常谈的问题——效率</p><p>一张大表比外键连接的效率是好的，虽然大表可能会产生占内存问题，而且很多一个元组中有过多的属性也会产生低效率，但是这个可以被索引解决。</p><p>但是我自己实践的过程中肯定是喜欢外键的，最大的原因之一是很多框架对外键的支持比较好，可以把外键当成List查询。听说有些公司喜欢不做外键（为了规避外键约束），但是我也不懂。</p></li><li><p>索引</p><p>索引是一种结构，它提供了基于一个或多个列值快速访问表中元组的方法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">UNIQUE</span>] <span class="keyword">INDEX</span> indexName <span class="keyword">ON</span></span><br><span class="line">Tablename(columnName[<span class="keyword">ASC</span>|<span class="keyword">DESC</span>][,...])</span><br></pre></td></tr></table></figure><p>索引只能基于表<strong>而非视图</strong>建立</p></li><li><p>自主访问控制</p><p>两种授权机制</p><ul><li>自主访问机制：每个用户被授予对特定的数据库对象的适当的访问权利。</li><li>强制访问机制：每个数据库对象被赋予特定分级，主体被赋予特定的许可证级别。主体需要必要的许可证级别来读写数据库对象。</li></ul><p>控制访问用<code>GRANT</code>和<code>REVOKE</code>操作。</p><p>可授权的操作：</p><ul><li>SELECT</li><li>INSERT</li><li>UPDATE</li><li>DELETE</li><li>REFERENCES可以允许在约束中引用这些列</li><li>USAGE（使用域/序列/字符集和转变规则（暂时跳过））</li></ul><p>授权</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GRANT &#123;PrivilegeList|ALL PRIVIEGES&#125;</span><br><span class="line">ON ObjectName</span><br><span class="line">TO &#123;AuthorizationIdList|PUBLIC&#125;</span><br><span class="line">[WITH GRANT OPTION]</span><br></pre></td></tr></table></figure><p>注意对于Privilege，SELECT, DELETE USAGE后面不用接列，INSERT，UPDATE和REFERENCE后面接列</p><p>WITH GRANT OPTION允许AuthorizationIdList给别人授权</p><p>撤销权限语法相近</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> [<span class="keyword">GRANT</span> <span class="keyword">OPTION</span> <span class="keyword">FOR</span>]&#123;PrivilegeList|ALL <span class="keyword">PRIVILEGES</span>&#125; <span class="keyword">ON</span> ObjectName</span><br><span class="line"><span class="keyword">FROM</span> &#123;AuthorizationIdList|<span class="keyword">PUBLIC</span>&#125; [RESTRICT|<span class="keyword">CASCADE</span>]</span><br></pre></td></tr></table></figure><p>GRANT OPTION FOR允许GRANT语句中的WITH GRANT OPTION传递的权限被撤销</p><p>RESTRICT 和CASCADE是针对REVOKE说的，在RESTRICT下，如果REVOKE导致一个对象（比如视图）被抛弃，则不能执行。</p><p>但是在CASCADE下所有因REVOKE而被抛弃的对象都将被依次抛弃</p></li></ol><h3 id="PLSQL"><a href="#PLSQL" class="headerlink" title="PLSQL"></a>PLSQL</h3><p>淦，内容怎么这么多，我都快没耐心了</p><p>PLSQL就是你懂的~Programming Language SQL</p><p>声明</p><figure class="highlight plain"><figcaption><span>VaRCHAR2(5);```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">想要与另一个列或变量类型相同，可以用`%TYPE`</span><br><span class="line"></span><br><span class="line">`vStaffNo Staff.staffNo%TYPE`</span><br><span class="line"></span><br><span class="line">赋值`:=`</span><br><span class="line"></span><br><span class="line">控制语句</span><br><span class="line"></span><br><span class="line">```plsql</span><br><span class="line">IF (condition) THEN</span><br><span class="line">...</span><br><span class="line">[ELSIF (condition) THEN ...]</span><br><span class="line">[ELSE ...]</span><br><span class="line">END IF;</span><br></pre></td></tr></table></figure><p>以及</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CASE(x)</span><br><span class="line">WHEN() THEN</span><br><span class="line">...</span><br><span class="line">END CASE;</span><br></pre></td></tr></table></figure><p>循环</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">label:</span><br><span class="line">LOOP</span><br><span class="line">...</span><br><span class="line">EXIT label [WHEN(condition)];</span><br><span class="line">END LOOP label;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">label:</span><br><span class="line">FOR item IN 下限..上限 LOOP</span><br><span class="line">...</span><br><span class="line">END LOOP label;</span><br></pre></td></tr></table></figure><h5 id="PLSQL游标"><a href="#PLSQL游标" class="headerlink" title="PLSQL游标"></a>PLSQL游标</h5><p>游标：游标就像一个指向查询结果中特定行的指针，游标可以前进一格，以便访问下一行</p><p>语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">DECLARE</span><br><span class="line">-- 在变量申明阶段就定义游标</span><br><span class="line">vName VARCHAR2(100)</span><br><span class="line">vAge NUMBER(10)</span><br><span class="line">-- 声明一个游标</span><br><span class="line">CURSOR studentCursor IS</span><br><span class="line">SELECT name, age FROM STUDENT</span><br><span class="line">WHERE STUDENT.SEX = &quot;m&quot;</span><br><span class="line">BEGIN</span><br><span class="line">--打开游标</span><br><span class="line">OPEN studentCursor;</span><br><span class="line">LOOP </span><br><span class="line">-- 用FECTCH将cursor中读出的元组中的值塞到声明的变量中</span><br><span class="line">FETCH studentCursor INTO vName, vAge;</span><br><span class="line">-- 当没有的时候用 %NOTFOUND 通知</span><br><span class="line">EXIT WHEN studentCursor%NOTFOUND;</span><br><span class="line">-- 用 || 连接字符串</span><br><span class="line">dbms_output.put_line(&apos;stuednt.name = &apos; || vName);</span><br><span class="line">dmbs_output.put_line(&apos;student.age = &apos; || vAge);</span><br><span class="line">END LOOP;</span><br><span class="line">CLOSE studentCursor;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure><p>这和JDBC中的<code>ResultSet</code>一个逻辑</p><h5 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h5><p>就整一函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">create or replace procedure &#123;procedureName&#125;</span><br><span class="line">    (parameterName [in|out|in out] parameterType,</span><br><span class="line">     ...)</span><br><span class="line"> as   </span><br><span class="line"> -- 这里相当于忽略了DECLARE</span><br><span class="line">variableName variableType;</span><br><span class="line"> begin  </span><br><span class="line"> -- 具体内容</span><br><span class="line">-- blabla </span><br><span class="line">...</span><br><span class="line">end;</span><br></pre></td></tr></table></figure><p>注意参数的IN /OUT /IN OUT</p><p>IN只能作为输入值</p><p>OUT只能作为输出值</p><p>IN OUT既可作为输入值，也可作为输出值</p><h5 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h5><p>触发器如果是习惯作UI的同学应该都是秒懂的</p><p>就是根据事件做出反应</p><p>语法为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TRIGGER triggerName</span><br><span class="line">&#123;BEFORE|AFTER|INSTEAD OF&#125;</span><br><span class="line">INSERT|DELETE|UPDATE OF COLUMNNAME1, COLUMNNAME2, ....</span><br><span class="line">ON TABLENAME</span><br><span class="line">REFERENCING OLD|NEW AS ROWNAME</span><br><span class="line">BEGIN</span><br><span class="line">....</span><br><span class="line">END;</span><br></pre></td></tr></table></figure><p>之前实践的时候想到一点：我觉得hibernate对PLSQL原生触发器的支持非常差。相对的，hibernate支持Java程序编写的事件监听器<code>EventListener</code>和拦截器<code>Interceptor</code>所以使用hibernate的时候就可以放弃触发器了</p><h3 id="DB设计"><a href="#DB设计" class="headerlink" title="DB设计"></a>DB设计</h3><h4 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h4><p><em>视图是为了得到另一个关系而对基关系作一次或多个关系操作的动态结果</em></p><p>视图是</p><ol><li>一个虚拟关系，并不存在于数据库中，需要特定用户的要求临时生成</li><li>一个或多个关系操作的动态结果</li></ol><p>CREATE代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE VIEW VIEWNAME [(COLUMNNAME1, ...)]</span><br><span class="line">AS </span><br><span class="line">... </span><br><span class="line">-- select 语句，比如</span><br><span class="line">-- select * from aTable</span><br><span class="line">[WITH[CASCADED|LOCAL] CHECK OPTION]</span><br></pre></td></tr></table></figure><p>视图就像个筛子，只会筛选出符合条件的元组（<code>WHERE</code>中的条件）</p><p>迁移行：如果对视图进行插入和更新时有新行满足或不满足<code>WHERE</code>条件则这些新行就会出现或消失在视图中</p><p>通过<code>WITH CHECK OPTION</code>限制迁移行。</p><p>有两个选项<code>CASCADED</code>和<code>LOCAL</code>，默认情况下都是<code>CASCADED</code></p><p><code>CASCADED</code>使任何对这个视图或其他的从这个视图创建的视图的插入与修改操作不得使行消失</p><p><code>LOCAL</code>使任何对这个视图或其他的从这个视图中创建的视图的插入和修改操作不得使行消失，除非在从这个视图中创建的所有视图这一行也消失了（不满足所有派生视图(derived view)的条件）</p><h5 id="视图分解"><a href="#视图分解" class="headerlink" title="视图分解"></a>视图分解</h5><p>视图分解时在查询视图的过程中，将用作视图定义的查询与在视图上的查询合并</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> view1 <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> A0, A1 <span class="keyword">FROM</span> A</span><br><span class="line"><span class="keyword">WHERE</span> A0 = <span class="number">1</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> A0 <span class="keyword">FROM</span> A <span class="keyword">WHERE</span> A1 = <span class="number">3</span></span><br></pre></td></tr></table></figure><p>可以转化为</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> A0 <span class="keyword">FROM</span> A <span class="keyword">WHERE</span> A0 = <span class="number">1</span> <span class="keyword">AND</span> A1 = <span class="number">3</span></span><br></pre></td></tr></table></figure><h5 id="视图的限制"><a href="#视图的限制" class="headerlink" title="视图的限制"></a>视图的限制</h5><ol><li>如果视图中某个列时由聚合函数产生的，那它只能被SELECT和ORDER BY</li><li>分组视图不能和基表或视图连接</li></ol><h5 id="视图可更新的限制"><a href="#视图可更新的限制" class="headerlink" title="视图可更新的限制"></a>视图可更新的限制</h5><ol><li>没有指定DISTINCT</li><li>定义的SELECT列表中的元素都是列名而不是聚合函数和常量和表达式。</li><li>FROM只指定一个表</li><li>WHERE子句不能引用FROM子句中的表的嵌套SELECT操作</li><li>不能有GROUP BY</li></ol><p>不能违反基表约束</p><h4 id="ER模型"><a href="#ER模型" class="headerlink" title="ER模型"></a>ER模型</h4><h5 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h5><p><em>能够独立存在的一组具有相同属性的对象</em></p><h5 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h5><p><em>实体类型键的一组有意义的关联</em></p><h5 id="度"><a href="#度" class="headerlink" title="度"></a>度</h5><p><em>参与联系的实体类型的个数</em></p><p>两个实体之间的关系就是二元关系，度为二</p><p>三个实体之间的关系就是三元关系，度为三</p><p>度为二以上的关系都被称作复杂关系</p><p>实际上多元关系都可以转化为二元关系</p><hr><p>属性，属性域，简单属性，复杂属性，单值属性，组合属性，单值属性，多值属性</p><p>以上我都懒得讲</p><h5 id="导出属性"><a href="#导出属性" class="headerlink" title="导出属性"></a>导出属性</h5><p><em>导出属性是从相关的一个或一组属性的值导出来的属性</em></p><p>注意导出属性算属性不算函数（别问我为什么说这个）</p><h5 id="候选关键字-1"><a href="#候选关键字-1" class="headerlink" title="候选关键字"></a>候选关键字</h5><h5 id="主关键字-1"><a href="#主关键字-1" class="headerlink" title="主关键字"></a>主关键字</h5><h5 id="合成关键字"><a href="#合成关键字" class="headerlink" title="合成关键字"></a>合成关键字</h5><p>包括两个或两个以上属性的候选关键字</p><p><img src="/2018/06/18/数据库复习/ER.png" alt="图形标识"></p><h5 id="陷阱"><a href="#陷阱" class="headerlink" title="陷阱"></a>陷阱</h5><ul><li>扇形陷阱：当一个实体连接了两个一对多实体时，会产生扇形陷阱</li></ul><p><img src="/2018/06/18/数据库复习/扇形陷阱.png" alt="扇形陷阱"></p><p>解决方案就是重新理解需求并且重构，做出1：M：N的结构出来</p><ul><li><p>断层陷阱：当一个实体与一些实体时1…M:1…N，但是与另一些实体产生了0…1: 0…*（有点说不清楚），几句产生了断层陷阱</p><p><img src="/2018/06/18/数据库复习/断层陷阱.png" alt="断层陷阱"></p><p>解决方案是跳过中间的断层直接作连接</p></li></ul><p>（陷阱有点讲不清楚）</p><p>增强ER模型就是在其基础上添加了OOP的继承和多态</p><h5 id="泛化的约束"><a href="#泛化的约束" class="headerlink" title="泛化的约束"></a>泛化的约束</h5><p>泛化有两种约束：参与约束和不相交约束</p><p>参与约束：<em>限制每个超类的成员是否一定是某个子类的成员</em>，是则Mandatory，不一定则Optional</p><p>不相交约束：<em>说明了超类的某一个成员是仅为一个还是同时为多个子类的成员</em>，仅为一个则为Or，可为多个则为And</p><p>这个可理解为支持多继承与否</p><p>假设：中国人，程序员，大学生都继承于人，但是一个人可以既是中国人又是程序员有时大学生，所以这个关系是And。</p><p>但是对于都继承于人的中国人美国人日本人来说，这个关系是<strong>互斥</strong>的(别和我说JOJO，谢谢)，所以这个关系是Or。</p><h4 id="规范化"><a href="#规范化" class="headerlink" title="规范化"></a>规范化</h4><p><em>生成一组既具有所期望的特性又能瞒住企业数据需求的关系的技术</em></p><p>性质：</p><ol><li>属性的个数最少</li><li>具有紧密逻辑联系的属性均在同一个关系中</li><li>最少的冗余，即每个属性只出现一次</li></ol><p>优点：</p><ol><li>易于用户访问</li><li>数据易于维护</li><li>计算机存储空间小</li></ol><p>缺点：</p><ol><li>性能相对降低</li></ol><h5 id="非规范化的数据库的异常"><a href="#非规范化的数据库的异常" class="headerlink" title="非规范化的数据库的异常"></a>非规范化的数据库的异常</h5><p>假设一张表记录了公司员工于所属公司的关系</p><p>它的函数依赖可以表示为</p><p>$staffNo, companyNo\rightarrow staffName, staffAge, staffBirthDay, companyName, companyAge$</p><p>其为部分函数依赖，即</p><p>$staffNo\rightarrow staffName, staffAge, staffBirthDay$</p><p>$companyNo\rightarrow companyName, companyAge$</p><p>那么当我插入staff的时候我就不得不填入company相关信息</p><p>如果修改staff信息也不得不加上company信息</p><p>如果删掉了一个公司中所有的staff之后，这个公司也不存在于表格中了</p><p>这在现实是极其难操作甚至说是做不到的</p><p>以上三个分别是插入异常、修改异常和删除异常</p><h5 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h5><p><em>描述一个关系中属性之间的联系。例如，假设A和B均为关系R的属性，若A的每个值都和B中的一个唯一的值，则称B函数依赖于A，记为$A\rightarrow B$</em></p><p>在实际操作中，A为超关键字组成，且多为主键</p><p>函数依赖分两种，完全函数依赖与部分函数依赖</p><p>完全函数依赖：<em>假设A和B是某一关系的属性（组），若B函数依赖于A，但是不函数依赖于A的某一真子集，则称B完全函数依赖于A</em></p><p>具体表示为</p><p>$c_0\rightarrow c_1, c_2, c_3, …, c_n$</p><p>部分函数依赖：<em>如果B函数依赖于A，但是B不是完全函数依赖于A，则是B部分依赖于A</em></p><p>具体表示为</p><p>$a_0, b_0\rightarrow a_1, a_2, a_3, b_1, b_2, b_3$</p><p>其中$b_i$与$a_0$无关，$a_i$与$b_0$无关</p><p>传递依赖：<em>假设A、B、C是某一关系的属性，若$A\rightarrow B$，$B\rightarrow C$， 则称C通过B依赖传递于A</em></p><h4 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h4><p>主要介绍第一范式，第二范式，第三范式</p><p>第一范式：<em>每一行和每一列相交的位置有且仅有一个值</em></p><p>直接理解的话，可以看成是避免ER模型中的组合属性，将组合属性拆成多个单值属性</p><p>（现实中的数据库系统应该都是默认遵循第一范式的吧……）</p><p>第二范式：<em>满足第一范式的要求并且每个非主关键字属性都完全依赖于主关键字</em></p><p>就是将上述的</p><p>$staffNo, companyNo\rightarrow staffName, staffAge, staffBirthDay, companyName, companyAge$</p><p>拆成</p><p>$staffNo\rightarrow staffName, staffAge, staffBirthDay, companyNo$</p><p>$companyNo\rightarrow companyName, companyAge$</p><p>两张表</p><p>这样可以避免多个无关的实体混合在一张表中。并使它们的关系通过外键连接</p><p>第三范式：<em>满足第一范式和第二范式的要求并且所有非主关键字属性都不传播依赖于主属性的关系</em></p><p>我认为这个是将第二范式无法拆分的表中实体的关系拆分出来。</p><p>第二范式就是拆分直接函数依赖于主键的实体关系，但是无法拆分间接依赖于主键的实体关系，第三范式就是处理这个问题。</p><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>事务定义：<em>由单个用户或者应用程序执行的，完成读取或者更新数据库内容的一个或多个操作</em></p><p>事务时数据库的逻辑处理单位</p><p>事务的性质：</p><ol><li>原子性：一个事务就是一个原子单位</li><li>一致性：事务必须将数据库从一种一致的状态转化为另一种一致的状态</li><li>隔离性：在有并发的时候，事务的执行时相互独立的。</li><li>持久性：事务完成的结果要永久保存在数据库中（在外存保存）。</li></ol><p>隔离性和持久性保证了原子性和一致性</p><p>####三个问题(四个)</p><h5 id="丢失更新"><a href="#丢失更新" class="headerlink" title="丢失更新"></a>丢失更新</h5><p>一个用户的更新操作被另一个用户所取代了</p><p><img src="/2018/06/18/数据库复习/丢失更新.png" alt="丢失更新"></p><h5 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h5><p>前提：允许一个事务看到另一个未提交事务的中间结果（违背隔离性）</p><p><img src="/2018/06/18/数据库复习/脏读.png" alt="脏读"></p><p>一个事务看到另一个事务在提交之前的中间结果，产生的读取数值误差</p><h5 id="不可重读问题"><a href="#不可重读问题" class="headerlink" title="不可重读问题"></a>不可重读问题</h5><p>在一个事务多次读取的时候另一个事务修改了数值，导致多次读取结果不一样</p><p><img src="/2018/06/18/数据库复习/不一致问题.png" alt="不一致问题"></p><h4 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h4><p>和不一致问题很像，但是是在query过程中</p><p>####可串行化</p><p>为了保证一致性，事务使用了可串行化方法</p><p>可串行化中冲突操作的顺序是非常重要的：</p><ol><li>如果两个事务只读，那就没有冲突，顺序也不重要</li><li>如果两个事务都读且写，但是读写的是完全不相干的两个数据项，也没有冲突，顺序也不重要</li><li>如果一个事务写入一个数据项，另一个事务读或写相同的数据项，他们就会有冲突，顺序就很重要</li></ol><p><img src="/2018/06/18/数据库复习/序列化.png" alt="序列化"></p><p>当一个事务于其他事务冲突的时候，使其延迟（传统方法）</p><p>可串行化是DBMS默认的正确性准则（correctness criterion）</p><p>缺点：可串行化计算开销大，可能会做一些无用的延迟</p><h4 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h4><p>共享锁：事务只能读不能修改数据项的锁</p><p>互斥锁：事务可以读可以改数据项的锁</p><h5 id="2PL两段锁协议"><a href="#2PL两段锁协议" class="headerlink" title="2PL两段锁协议"></a>2PL两段锁协议</h5><p>这个锁只有两个阶段：</p><ol><li>扩展阶段：所有事务可以获取它们要的锁，但是不能释放任何锁</li><li>收缩阶段：所有事务可以释放它所拥有的锁，但是不能获取它们要的锁</li></ol><p>这个协议可以达到满足事务安全（解决那三个问题）的最快效率</p><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>定义大家都懂的~</p><p>#####解决方案</p><ol><li>超时</li></ol><p>设定一个极限时间，如果一个事务等待加锁的事务的等待时间超过它，则回滚此事务并重启</p><p>问题是：极限实践设置长了之后对解决死锁帮助不大，设置断了对长事务不友好</p><ol start="2"><li>Waiting-for Graph(WFG)<br>通过WFG可以展示事务的依赖关系并且判断死锁<br>算法流程：</li><li>对每一个事务做一个节点</li><li>创造边$T_i\rightarrow T_j$如果$T_i$等待$T_j$锁住的资源</li><li>如果图中存在一个环，则死锁存在</li></ol><h4 id="孤立等级"><a href="#孤立等级" class="headerlink" title="孤立等级"></a>孤立等级</h4><p>由于序列化有一些缺陷，SQL允许程序员设定孤立等级</p><p>SQL标准中有四个孤立等级</p><ul><li>READ  UNCOMMITTED：允许脏读</li><li>READ COMMIT：不允许脏读</li><li>REPEATABLE READ：避免脏读和不可重读问题，但是无法避免幻读</li><li>SERIALIZABILITY：避免所有的问题</li></ul><p>注意：ORACLE只实现了SQL标准中的两个，即READ COMMITTED和 SERIALIZABLE</p><h4 id="数据恢复"><a href="#数据恢复" class="headerlink" title="数据恢复"></a>数据恢复</h4><p>自己看</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据库复习&quot;&gt;&lt;a href=&quot;#数据库复习&quot; class=&quot;headerlink&quot; title=&quot;数据库复习&quot;&gt;&lt;/a&gt;数据库复习&lt;/h1&gt;&lt;h2 id=&quot;概要&quot;&gt;&lt;a href=&quot;#概要&quot; class=&quot;headerlink&quot; title=&quot;概要&quot;&gt;&lt;/a&gt;概
      
    
    </summary>
    
    
      <category term="课程复习" scheme="http://ChenKardel.github.io/tags/%E8%AF%BE%E7%A8%8B%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="数据库" scheme="http://ChenKardel.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>UNIX环境高级编程前部分介绍</title>
    <link href="http://ChenKardel.github.io/2018/06/15/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E5%89%8D%E9%83%A8%E5%88%86%E4%BB%8B%E7%BB%8D/"/>
    <id>http://ChenKardel.github.io/2018/06/15/UNIX环境高级编程前部分介绍/</id>
    <published>2018-06-15T13:25:02.000Z</published>
    <updated>2018-06-16T03:22:42.040Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>苦逼本科生要考试，考试还奇难内容齐多</p><p>这里我整理一下考试提纲</p><p>正好这也是对《unix环境高级编程》的前半部分的一个总结</p><p>就当看着乐</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="什么是操作系统？什么是UNIX操作系统？什么是Linux操作系统？它们之间的关系是怎样的？"><a href="#什么是操作系统？什么是UNIX操作系统？什么是Linux操作系统？它们之间的关系是怎样的？" class="headerlink" title="什么是操作系统？什么是UNIX操作系统？什么是Linux操作系统？它们之间的关系是怎样的？"></a>什么是操作系统？什么是UNIX操作系统？什么是Linux操作系统？它们之间的关系是怎样的？</h3><p>操作系统是管理和控制计算机硬件和软件资源的计算机程序，是直接运行在“裸机”上的最基本的系统软件。</p><p>UNIX是一个与1969年在AT&amp;T的贝尔实验室开发的多用户多任务的分时的操作系统</p><p>Linux是一个基于POSIX和UNIX的多用户、多任务、支持多线程的开源的由Linus开发的操作系统</p><p>Linux是基于UNIX而构造的。</p><h3 id="UNIX操作系统有哪些典型的分支？"><a href="#UNIX操作系统有哪些典型的分支？" class="headerlink" title="UNIX操作系统有哪些典型的分支？"></a>UNIX操作系统有哪些典型的分支？</h3><p>Solaris，Linux，HP-UX，FreeBSD，SunOS，MacOS</p><h3 id="什么是Shell？内置变量-、-、-、-、-的具体含义是什么？"><a href="#什么是Shell？内置变量-、-、-、-、-的具体含义是什么？" class="headerlink" title="什么是Shell？内置变量$、$*、$@、$?、$#的具体含义是什么？"></a>什么是Shell？内置变量$、$*、$@、$?、$#的具体含义是什么？</h3><p><code>$$</code> 指当前shell进程的pid</p><p><code>$*</code>指的是传递给脚本的所有参数</p><p><code>$@</code>也是把所有参数传递给脚本，但是当参数被双引号包含的时候，<code>$*</code>会把所有的参数作为一个整体，而<code>$@</code>会将各个参数分开</p><p><code>$?</code>指的是上个命令的退出状态，或函数返回值</p><p><code>$#</code>指的是传递给脚本或函数的参数个数</p><p><a href="https://www.cnblogs.com/davygeek/p/5670212.html" target="_blank" rel="noopener">Shell特殊变量：Shell  \$0, \$#, \$*, \$@, \$?, \$$和命令行参数</a></p><p>###常用的Shell命令，如ls、cd、dd、pwd、ps、cp、chown、chmod、mkdir、size等的具体用法。</p><p>ls (list)列出所有文件</p><p>cd (change directory)换工作目录</p><p>dd (disk dump)指定大小拷贝文件</p><p>pwd (print working directory)打印工作目录</p><p>ps (processes status) 显示终端下所有进程</p><p>cp （copy）复制</p><p>chown (change owner)改变文件的所有者</p><p>chmod (change mode )改变文件的权限模式</p><p>mkdir (make directory)</p><p>size 显示目标文件长度</p><h3 id="什么是管道？哪些文件参与了管道？在命令行下和通过编程如何实现管道？"><a href="#什么是管道？哪些文件参与了管道？在命令行下和通过编程如何实现管道？" class="headerlink" title="什么是管道？哪些文件参与了管道？在命令行下和通过编程如何实现管道？"></a>什么是管道？哪些文件参与了管道？在命令行下和通过编程如何实现管道？</h3><p>管道是进程间的通信的工具</p><p>stdin, stdout, stderr三个文件参与了管道</p><p>在命令行下，可以通过”|”实现管道。前一个进程产生的输入传输道后一个进程之中。</p><p>在linux c下，可以通过pipe去实现管道</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">无名管道的生成</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pipefd[<span class="number">2</span>]; <span class="comment">// pipefd[0]是输入fd, pipefd[1]是输出fd</span></span><br><span class="line">    pipe(pipefd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常规文件和目录文件的差别是什么？常规文件、目录文件、软链接文件的长度如何计算？"><a href="#常规文件和目录文件的差别是什么？常规文件、目录文件、软链接文件的长度如何计算？" class="headerlink" title="常规文件和目录文件的差别是什么？常规文件、目录文件、软链接文件的长度如何计算？"></a>常规文件和目录文件的差别是什么？常规文件、目录文件、软链接文件的长度如何计算？</h3><p>目录文件也是一种特殊的文件，里面存放的是父目录节点和孩子文件。</p><p>常规文件只要用户拥有读权限就可以读，如果用户拥有写权限就可以写。</p><p>目录文件的读只需用户拥有这个目录的读权限，但是写时靠操作系统内核写的。</p><p>常规文件的长度根据其内容计算。</p><p>目录大小根据目录文件对应的inode的Block的大小。一般文件不多的情况下都是4096即4K的大小。而一般情况下都是4K的n倍，n取决于目录下文件的数量</p><p>软链接的文件长度就是目标文件的文件名字符长度，就比如一个指向<code>AAA</code>的软连接的文件大小是3，因为<code>AAA</code>有三个字符</p><h3 id="怎样移动文件？在命令行方式下和通过编程如何实现？"><a href="#怎样移动文件？在命令行方式下和通过编程如何实现？" class="headerlink" title="怎样移动文件？在命令行方式下和通过编程如何实现？"></a>怎样移动文件？在命令行方式下和通过编程如何实现？</h3><p>在命令行的方式下，可以通过mv命令来移动文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv oldFile oneDir/newFile</span><br></pre></td></tr></table></figure><p>在Linux C下貌似没有直接移动文件的函数，但是可以通过创建硬链接和删除原有链接的方式实现</p><p>但是可以使用<code>rename()</code>函数，取得同样的效果</p><h3 id="怎样利用gcc编译源文件？gcc的-o、-e、-static、-Wall等选项的具体含义是什么？怎样使用？"><a href="#怎样利用gcc编译源文件？gcc的-o、-e、-static、-Wall等选项的具体含义是什么？怎样使用？" class="headerlink" title="怎样利用gcc编译源文件？gcc的-o、-e、-static、-Wall等选项的具体含义是什么？怎样使用？"></a>怎样利用gcc编译源文件？gcc的-o、-e、-static、-Wall等选项的具体含义是什么？怎样使用？</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc cFile.c</span><br></pre></td></tr></table></figure><p>生成一个名为a.out的可执行文件</p><p>-o可以指定生成文件的名字</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o test cFile.c</span><br></pre></td></tr></table></figure><p>之后生成名为test的可执行文件</p><p>-E只激活预处理，并不生成文件</p><p>需要将其重定向到一个输出文件里面</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E cFile.c &gt; redirector.c</span><br></pre></td></tr></table></figure><p>-static静态编译，生成的文件不依赖动态链接库而使用静态链接库，可移植性高，缺点是生成的可执行文件非常大</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -static cFile.c</span><br></pre></td></tr></table></figure><p>-Wall在编译过程中会显示所有的warning信息</p><h3 id="什么是动态链接库？什么是静态链接库？怎样用静态链接的方式编译C程序？"><a href="#什么是动态链接库？什么是静态链接库？怎样用静态链接的方式编译C程序？" class="headerlink" title="什么是动态链接库？什么是静态链接库？怎样用静态链接的方式编译C程序？"></a>什么是动态链接库？什么是静态链接库？怎样用静态链接的方式编译C程序？</h3><p>动态链接库(dynamic link library, dll)是指可以c等编程语言在变编译时候依赖的库。在编译过程中这些库不会链接到可执行文件中，所以文件大小比较小，缺点是可移植性不强</p><p>静态链接库(.lib文件)是在c等编程语言在编译的时候将库链接到可执行文件中，所以文件大小比较大，但是又较好的可移植性</p><p>gcc默认使用动态链接地方式编译，如果想使用静态链接就需要用-static选项</p><h3 id="什么是文件系统？UNIX的文件系统有什么特点？有哪些具体的文件类型？"><a href="#什么是文件系统？UNIX的文件系统有什么特点？有哪些具体的文件类型？" class="headerlink" title="什么是文件系统？UNIX的文件系统有什么特点？有哪些具体的文件类型？"></a>什么是文件系统？UNIX的文件系统有什么特点？有哪些具体的文件类型？</h3><p>文件系统是操作系统在存储设备上组织文件的方法和数据结构。</p><p>UNIX的文件系统是依靠inode的vnode的。</p><p>在进程表项中都维护一个文件表，文件表中有文件状态标志、当前文件的偏移量和vnode指针。vnode指针指向了一个vnode节点，其中包含了vnode节点信息和对inode的指针。</p><p>inode指向了磁盘上的文件。</p><p>磁盘上的文件至少对应一个inode，当一个文件的inode达到0时，文件被正式删除。</p><p>每个目录的硬链接数至少有2个，自己与父目录。</p><p>具体的文件类型：</p><ul><li>常规文件</li><li>目录文件</li><li>字符特殊文件：对设备不带缓冲的访问</li><li>块特殊文件：对设备带缓冲的访问</li><li>FIFO：用于进程间的通信</li><li>套接字：用于进程间的网络通信</li><li>软链接</li></ul><h3 id="什么是文件的访问权限？使用chmod命令怎样改变访问权限？chmod-0777是什么意思？"><a href="#什么是文件的访问权限？使用chmod命令怎样改变访问权限？chmod-0777是什么意思？" class="headerlink" title="什么是文件的访问权限？使用chmod命令怎样改变访问权限？chmod 0777是什么意思？"></a>什么是文件的访问权限？使用chmod命令怎样改变访问权限？chmod 0777是什么意思？</h3><p>访问权限指的是文件是否可以被不同类型的人访问的标识符</p><p>chmod</p><p>在shell中是</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod u+x g+w filename #user现在可以执行，group现在可以写入</span><br><span class="line">chmod u=rwx g=rw o=r filename #对于filename来说，user现在read write execute都被允许，group只被允许read和write，other可以read</span><br></pre></td></tr></table></figure><p>chmod 0777代表着对于user/group/others来说，都可以对filename读写执行了</p><h3 id="什么是文件操作是的偏移量（offset）？它的数据类型是什么？操作系统中文件的最大长度取决于什么？"><a href="#什么是文件操作是的偏移量（offset）？它的数据类型是什么？操作系统中文件的最大长度取决于什么？" class="headerlink" title="什么是文件操作是的偏移量（offset）？它的数据类型是什么？操作系统中文件的最大长度取决于什么？"></a>什么是文件操作是的偏移量（offset）？它的数据类型是什么？操作系统中文件的最大长度取决于什么？</h3><p>偏移量指的是现在文件操作的指针指向的是文件的第几个字节。</p><p>数据类型是offset_t</p><p>操作系统中文件的最大长度取决于文件自身的字节数和块大小。#有点迷，不回答</p><h3 id="什么是管道？什么是文件重定向？dup-、dup2-函数怎样使用？"><a href="#什么是管道？什么是文件重定向？dup-、dup2-函数怎样使用？" class="headerlink" title="什么是管道？什么是文件重定向？dup()、dup2()函数怎样使用？"></a>什么是管道？什么是文件重定向？dup()、dup2()函数怎样使用？</h3><p>管道是进程间的通信的工具</p><p>文件重定向是指将进程的标准输出或标准输入换成文件流 </p><p><code>int dup(int oldd);</code></p><p>dup返回新文件描述符是当前可用文件描述符中的最小值</p><p><code>int dup2(int fd, int fd2);</code></p><p>dup2可以用fd2指定新描述符的值，如果fd2已经打开，则先将其关闭。</p><h3 id="什么是文件的静态属性和动态属性（文件描述符属性）？在文件描述符属性中，哪些是由进程维护的？哪些是由内核维护的？"><a href="#什么是文件的静态属性和动态属性（文件描述符属性）？在文件描述符属性中，哪些是由进程维护的？哪些是由内核维护的？" class="headerlink" title="什么是文件的静态属性和动态属性（文件描述符属性）？在文件描述符属性中，哪些是由进程维护的？哪些是由内核维护的？"></a>什么是文件的静态属性和动态属性（文件描述符属性）？在文件描述符属性中，哪些是由进程维护的？哪些是由内核维护的？</h3><p>静态属性：由stat()函数显示的文件属性都是静态属性。包括…. ls -l的结果都是</p><p>动态属性：</p><p>进程维护：</p><h3 id="什么是会话（Session）、进程组？它们之间有什么关系？"><a href="#什么是会话（Session）、进程组？它们之间有什么关系？" class="headerlink" title="什么是会话（Session）、进程组？它们之间有什么关系？"></a>什么是会话（Session）、进程组？它们之间有什么关系？</h3><p>进程组是一个或多个进程的集合</p><p>会话是一个或多个进程组的集合。</p><p>关系：会话是一个或多个进程组的集合。</p><h3 id="父进程和子进程之间是什么关系？怎样在父子进程之间共享文件描述符？"><a href="#父进程和子进程之间是什么关系？怎样在父子进程之间共享文件描述符？" class="headerlink" title="父进程和子进程之间是什么关系？怎样在父子进程之间共享文件描述符？"></a>父进程和子进程之间是什么关系？怎样在父子进程之间共享文件描述符？</h3><p>父进程通过调用fork函数生成子进程，并且通过waitpid的方式回收子进程使其不成为僵尸进程。在子进程未通过调用exec执行新的代码的时候，父进程与子进程的所有信息完全相同，包括文件表。</p><p>在子进程创建之初就已经共享文件描述符（因为父进程与子进程的文件表相同。）只要在fork之前打开的文件，都可以被父子进程共享。</p><h3 id="在一个进程中，文件描述符的增长规律是怎样的？例如，如果已经有0、1、2、6这样几个文件描述符，那么用open-返回的下一个文件描述符是什么？"><a href="#在一个进程中，文件描述符的增长规律是怎样的？例如，如果已经有0、1、2、6这样几个文件描述符，那么用open-返回的下一个文件描述符是什么？" class="headerlink" title="在一个进程中，文件描述符的增长规律是怎样的？例如，如果已经有0、1、2、6这样几个文件描述符，那么用open()返回的下一个文件描述符是什么？"></a>在一个进程中，文件描述符的增长规律是怎样的？例如，如果已经有0、1、2、6这样几个文件描述符，那么用open()返回的下一个文件描述符是什么？</h3><p>是最小的未被使用的的非负整数。3</p><h3 id="什么是process-id？父进程和子进程的pid之间有什么关系？（通常子进程的pid要大于父进程的pid）"><a href="#什么是process-id？父进程和子进程的pid之间有什么关系？（通常子进程的pid要大于父进程的pid）" class="headerlink" title="什么是process id？父进程和子进程的pid之间有什么关系？（通常子进程的pid要大于父进程的pid）"></a>什么是process id？父进程和子进程的pid之间有什么关系？（通常子进程的pid要大于父进程的pid）</h3><p>process id 即进程id，是一个进程独有的编号；</p><p>父进程总是会比子进程先创建出来，故父亲的pid&lt;子进程pid。</p><h3 id="什么是C语言程序的入口函数？在C-Startup-Routine（start-S）中接受的main函数原型是什么？"><a href="#什么是C语言程序的入口函数？在C-Startup-Routine（start-S）中接受的main函数原型是什么？" class="headerlink" title="什么是C语言程序的入口函数？在C Startup Routine（start.S）中接受的main函数原型是什么？"></a>什么是C语言程序的入口函数？在C Startup Routine（start.S）中接受的main函数原型是什么？</h3><p>C语言程序的入口函数是main函数。C程序总是从main函数开始执行。</p><p>在c语言编译过程中，从<code>_start</code>开始执行。</p><p>而<code>_start</code>会调用<code>libc_start_main函数，libc_start_main这个函数的第一个参数就是指向一个</code>main<code>函数的指针</code></p><p><code>main</code>函数的签名为<code>int main(int argc, char **argv, char** environ)</code>三个参数分别代表参数的个数，参数和环境变量。</p><h3 id="什么是系统调用？什么是C语言库函数？它们之间有什么区别和联系？"><a href="#什么是系统调用？什么是C语言库函数？它们之间有什么区别和联系？" class="headerlink" title="什么是系统调用？什么是C语言库函数？它们之间有什么区别和联系？"></a>什么是系统调用？什么是C语言库函数？它们之间有什么区别和联系？</h3><p>系统调用：unix操作系统所提供的良好定义、数量有限、之间进入内核的入口点</p><p>C语言库函数：这里指的是程序员使用的通用库函数。虽然折现函数可能会调用一个或多个内核的系统调用，但是它们都不是内核的入口点</p><p>联系：它们都通过C函数的形式出现并且都为应用程序提供服务</p><p>区别：</p><ol><li>库函数是可以灵活地被替换的，但是系统调用不是</li><li>两者的职责和操作的层面不同。库函数常在用户层次管理上而系统调用在内核层次上</li></ol><h3 id="什么是inode？里面存放什么信息？文件的文件名存放在哪里？"><a href="#什么是inode？里面存放什么信息？文件的文件名存放在哪里？" class="headerlink" title="什么是inode？里面存放什么信息？文件的文件名存放在哪里？"></a>什么是inode？里面存放什么信息？文件的文件名存放在哪里？</h3><p>inode是索引节点，是UNIX操作系统中包含文件系统重要信息的一种数据结构。</p><p>里面存放了包括文件所有者，文件长度，文件在磁盘上的位置的指针等等信息。</p><p>文件的文件名存放在目录项中</p><h3 id="C程序的内存布局是怎样的？从低地址到高地址依次存放哪些段？"><a href="#C程序的内存布局是怎样的？从低地址到高地址依次存放哪些段？" class="headerlink" title="C程序的内存布局是怎样的？从低地址到高地址依次存放哪些段？"></a>C程序的内存布局是怎样的？从低地址到高地址依次存放哪些段？</h3><p>从低到高：代码段，初始化过的数据，未初始化过的数据，堆，栈，命令行参数和环境变量</p><p>其中程序的静态变量都放在代码段中。</p><p>在栈中，后入的变量居于低地址，先入的变量居于高地址</p><h3 id="怎样利用fork-、exec-、waitpid-来创建和控制进程？"><a href="#怎样利用fork-、exec-、waitpid-来创建和控制进程？" class="headerlink" title="怎样利用fork()、exec()、waitpid()来创建和控制进程？"></a>怎样利用fork()、exec()、waitpid()来创建和控制进程？</h3><p>父进程调用fork()，之后程序中应该有一个条件判断判断是否为子进程，如果是，则子进程调用exec，并且会将if中其他代码全部替换掉。之后，父进程执行waitpid，回收子进程，防止其变为僵尸进程</p><h3 id="什么是孤儿进程、什么是僵尸进程？它们有什么特点？怎样避免产生过多僵尸进程？"><a href="#什么是孤儿进程、什么是僵尸进程？它们有什么特点？怎样避免产生过多僵尸进程？" class="headerlink" title="什么是孤儿进程、什么是僵尸进程？它们有什么特点？怎样避免产生过多僵尸进程？"></a>什么是孤儿进程、什么是僵尸进程？它们有什么特点？怎样避免产生过多僵尸进程？</h3><p>孤儿进程就是指父进程早于子进程结束，从而没有父进程的子进程</p><p>孤儿进程会被1号进程托管，并且在结束的时候被回收</p><p>僵尸进程就是指由于种种原因，父进程迟迟不使用<code>wait</code>和<code>waitpid</code>回收的子进程</p><p>僵尸进程一直在进程表中占有一个进程表象，但并没有占用任何资源（因为进程结束的时候资源早已回收）</p><p>可以使用两次fork的方法避免产生过多的僵尸进程。调用两次fork然后直接杀死子进程，留下孙子进程被1号进程托管，待其结束被1号进程回收。</p><h3 id="什么是前台进程？什么是后台进程？一个会话有几个前台进程组和几个后台进程组？"><a href="#什么是前台进程？什么是后台进程？一个会话有几个前台进程组和几个后台进程组？" class="headerlink" title="什么是前台进程？什么是后台进程？一个会话有几个前台进程组和几个后台进程组？"></a>什么是前台进程？什么是后台进程？一个会话有几个前台进程组和几个后台进程组？</h3><p>前台进程：用户使用的有控制终端的进程 </p><p>后台进程：是运行在后台的一种特殊进程。但仍联系控制终端并且周期性地执行某种任务或者等待处理某些发生的事件。</p><p>attention: 后台进程和守护进程并不是一个概念。守护进程完全独立于控制终端而后台进程并没有</p><p>在控制终端终止时，后台进程会随着前台进程一起终止，但是守护进程不会</p><p>守护进程会常驻内存，防止关掉控制终端内存消失</p><p><a href="https://www.cnblogs.com/virusolf/p/5420152.html" target="_blank" rel="noopener">后台进程不等于守护进程</a></p><p>一个会话中包含一个前台进程组，一个或多个后台进程组。 </p><h3 id="C程序如何退出并返回操作系统？exit-函数和-exit-Exit-函数的差别在哪里？"><a href="#C程序如何退出并返回操作系统？exit-函数和-exit-Exit-函数的差别在哪里？" class="headerlink" title="C程序如何退出并返回操作系统？exit()函数和_exit()/_Exit()函数的差别在哪里？"></a>C程序如何退出并返回操作系统？exit()函数和_exit()/_Exit()函数的差别在哪里？</h3><p>进程的终止方式有 8 种,其中 5 种为正常终止</p><ol><li>从 main 返回。   </li><li>调用 exit。   </li><li>调用_exit 或_Exit。   </li><li>最后一个线程从其启动例程返回。   </li><li>最后一个线程调用pthread_exit。   </li></ol><p>另外三种为异常终止方式,它们是   </p><ol><li>调用 abort。   </li><li>接到一个信号并终止。   </li><li>最后一个线程对取消请求做出响应。  </li></ol><p><code>void exit(int status)</code></p><p><code>void _Exit(int status)</code></p><p><code>void _exit(int status)</code></p><p>第一个是C语言的库函数</p><p>第二个是系统调用的POSIX标准的函数</p><p>第三个系统调用的ISO标准的函数</p><p>系统调用的特点是系统调用不会调用退出处理函数，但是C语言的库函数会</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by kardel on 5/28/18.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_syscall</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"HelloWorld"</span>);</span><br><span class="line">    _Exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_clib</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"HelloWorld"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"in clib:\n"</span>);</span><br><span class="line">        print_clib();</span><br><span class="line"><span class="comment">//        printf("in syscall:\n");</span></span><br><span class="line"><span class="comment">//        print_syscall();</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的结果是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">in clib:</span><br><span class="line">HelloWorld</span><br></pre></td></tr></table></figure><p>如果注释掉上面两行，结果是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">in syscall:</span><br></pre></td></tr></table></figure></p><p>因为printf的打印在结束调用函数中，但是_Exit()直接退出，就不存在结束调用</p><h3 id="exec函数族包含哪些具体的函数？其中execve是系统调用，其它都是普通函数。"><a href="#exec函数族包含哪些具体的函数？其中execve是系统调用，其它都是普通函数。" class="headerlink" title="exec函数族包含哪些具体的函数？其中execve是系统调用，其它都是普通函数。"></a>exec函数族包含哪些具体的函数？其中execve是系统调用，其它都是普通函数。</h3><table><thead><tr><th>函数签名</th><th>解释</th></tr></thead><tbody><tr><td><code>int execl(const char * pathname, const char * arg0, .../*, NULL*/);</code></td><td>根据pathname所代表的文件路径通过给定的参数执行进程。注意arg0应该是程序本身</td></tr><tr><td><code>int execle(const char * pathname, const char * arg0, ..., /*, NULL, char * const envp[]*/);</code></td><td>根据pathname所代表的文件路径通过给定的参数执行进程。最后一个参数是环境变量数组。注意arg0是程序本身</td></tr><tr><td><code>int execlp(const char * pathname, const char * arg0, ... /*, NULL*/);</code></td><td>在环境变量中根据pathname找文件并且通过给定参数执行进程。注意arg0应该是程序本身</td></tr><tr><td><code>int execv(const char * pathname, char * const argv[]);</code></td><td>根据pathname所代表的文件路径通过给定的参数的数组执行进程。注意数组第一个元素应该是程序本身</td></tr><tr><td><code>int execvp(const char * pathname, const char * arg0);</code></td><td>在环境变量中根据pathname找文件并且通过给定参数的数组执行进程。注意数组第一个元素应该是程序本身</td></tr><tr><td><code>int fexecve(int fd, char * const argv[], char * const envp[]);</code></td><td>在环境变量中根据file descriptor找文件并且通过给定参数的数组执行进程。注意数组第一个元素应该是程序本身。最后一个参数是环境变量数组</td></tr><tr><td><code>int execve(const char * pathname, char * const argv[], char * const envp[]);</code></td><td>真正的系统调用。根据pathname所代表的文件路径通过给定的参数的数组执行进程。注意数组第一个元素应该是程序本身。最后一个参数是环境变量数</td></tr></tbody></table><p>###*什么是信号？SIGINT、SIGSTOP、SIGHUP、SIGALARM、SIGQUIT等信号是如何产生的？缺省的处理动作是什么？    </p><p>信号是异步事件通知进程的一种方式。 </p><p>信号处理函数靠内核进行</p><p>因为这个已经脱离了用户自定义的范围，转而变成了操作系统的范围</p><p>信号产生的方法：</p><ol><li><p>用户通过按某些终端键可以引发终端产生信号</p></li><li><p>硬件异常产生信号</p></li><li><p>用户可以通过kill函数讲任意信号发给另一个进程或进程组。接收信号的进程和发送信号的进程的所有者必须相同。或者发送信号进程的所有者是超级用户</p></li><li><p>用户通过kill命令讲信号发送给其他进程</p></li><li><p>当检测到某种软件条件已经发生并应该将其通知有关进程时也产生信号。</p><p>这四个缺省的处理动作都是终止。</p></li></ol><h3 id="什么是硬链接和软链接（符号链接）？读取软连接的函数是什么？（readlink）"><a href="#什么是硬链接和软链接（符号链接）？读取软连接的函数是什么？（readlink）" class="headerlink" title="什么是硬链接和软链接（符号链接）？读取软连接的函数是什么？（readlink）"></a>什么是硬链接和软链接（符号链接）？读取软连接的函数是什么？（readlink）</h3><p>硬链接：通过 i 节点链接使多个目录项指向同一个文件的这种链接类型。   </p><p>符号链接：对一个文件的间接指针，一般用于将一个文件或整个目录结构移到文件系统中的另一个位置。</p><p><code>ssize_t readlink(const char * restrict pathname, char * restrict buf, size_t bufsize)</code>可以打开软连接并且读该软链接中的名字 </p><h3 id="函数link-和unlink-的作用是什么？什么时候文件占用的磁盘空间才会真正被释放掉？（两个条件）"><a href="#函数link-和unlink-的作用是什么？什么时候文件占用的磁盘空间才会真正被释放掉？（两个条件）" class="headerlink" title="函数link()和unlink()的作用是什么？什么时候文件占用的磁盘空间才会真正被释放掉？（两个条件）"></a>函数link()和unlink()的作用是什么？什么时候文件占用的磁盘空间才会真正被释放掉？（两个条件）</h3><p><code>int link(const char * existingpath, const char * newpath);</code>根据existingpath创造一个路径为newpath的硬链接。</p><p><code>int unlink(const char * pathname);</code>删除一个硬链接</p><p>当：</p><ol><li><p>没有硬链接指向文件</p></li><li><p>进程关闭该文件或进程终止</p><p>时，在磁盘空间内的文件才会被释放掉</p></li></ol><h3 id="什么是可重入函数？怎样判断一个函数是不是可重入函数？"><a href="#什么是可重入函数？怎样判断一个函数是不是可重入函数？" class="headerlink" title="什么是可重入函数？怎样判断一个函数是不是可重入函数？"></a>什么是可重入函数？怎样判断一个函数是不是可重入函数？</h3><p>可重入函数是在信号处理程序中保证调用安全的函数。</p><p>不是可重入函数的几个特点：</p><ol><li>使用静态数据结构</li><li>他们调用<code>malloc</code>或<code>free</code></li><li>它们是标准I/O函数</li></ol><h3 id="什么是带缓冲的输出和不带缓冲的输出？当父进程的输出缓冲区还未清空时，调用fork创建子进程，会出现什么情况？"><a href="#什么是带缓冲的输出和不带缓冲的输出？当父进程的输出缓冲区还未清空时，调用fork创建子进程，会出现什么情况？" class="headerlink" title="什么是带缓冲的输出和不带缓冲的输出？当父进程的输出缓冲区还未清空时，调用fork创建子进程，会出现什么情况？"></a>什么是带缓冲的输出和不带缓冲的输出？当父进程的输出缓冲区还未清空时，调用fork创建子进程，会出现什么情况？</h3><p>不带缓冲的输出是在调用时直接将内容输出到标准输出端/文件，而不是经过缓冲区。比如<code>printf</code>函数</p><p>带缓冲区的输出实在调用的时候将内容缓冲在缓冲区，等到程序结束了再一并写入输入端/文件，比如<code>fprintf</code>函数</p><p>会打印两次相同的内容</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line">   <span class="comment">// Created by kardel on 5/28/18.</span></span><br><span class="line">   <span class="comment">//</span></span><br><span class="line">   </span><br><span class="line">   <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line">   <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">   <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line">   <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       FILE *fd = fopen(<span class="string">"test.txt"</span>, <span class="string">"a"</span>);</span><br><span class="line">       <span class="keyword">char</span> * buffer = <span class="string">"HELLO\n"</span>;</span><br><span class="line">       fwrite(buffer, <span class="number">6</span>, <span class="number">1</span>, fd);</span><br><span class="line">       <span class="keyword">int</span> pid = fork();</span><br><span class="line">       <span class="comment">//我懒得写waitpid,僵尸就僵尸吧</span></span><br><span class="line">   </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>可以看见在test.txt中的内容是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HELLO</span><br><span class="line">HELLO</span><br></pre></td></tr></table></figure></p><h3 id="编程的题目在这次考试中占很大的比重。一共有两道编程的题目。第一道跟文件操作相关，要求详细掌握的用法包括：能用open-read-write-close等函数来操纵文件；能利用lseek来形成文件中的“空洞”；能动态申请和释放空间等。"><a href="#编程的题目在这次考试中占很大的比重。一共有两道编程的题目。第一道跟文件操作相关，要求详细掌握的用法包括：能用open-read-write-close等函数来操纵文件；能利用lseek来形成文件中的“空洞”；能动态申请和释放空间等。" class="headerlink" title="编程的题目在这次考试中占很大的比重。一共有两道编程的题目。第一道跟文件操作相关，要求详细掌握的用法包括：能用open,read,write,close等函数来操纵文件；能利用lseek来形成文件中的“空洞”；能动态申请和释放空间等。"></a>编程的题目在这次考试中占很大的比重。一共有两道编程的题目。第一道跟文件操作相关，要求详细掌握的用法包括：能用open,read,write,close等函数来操纵文件；能利用lseek来形成文件中的“空洞”；能动态申请和释放空间等。</h3><p>注意点: <code>lseek</code>形成文件空洞之后要立即写入起码一个字节，否则空洞无效。</p><p>几个文件状态：</p><table><thead><tr><th>文件状态标志</th><th>说明</th></tr></thead><tbody><tr><td>O_RDONLY</td><td>只读打开</td></tr><tr><td>O_WRONLY</td><td>只写打开</td></tr><tr><td>O_RDWR</td><td>读写打开</td></tr><tr><td>O_EXEC</td><td>只执行打开</td></tr><tr><td>O_SEARCH</td><td>只搜索打开目录</td></tr><tr><td>O_APPEND</td><td>只添加新内容</td></tr><tr><td>O_NONBLOCK</td><td>非堵塞</td></tr><tr><td>O_SYNC</td><td>等待写完成（数据与属性）</td></tr><tr><td>O_DSYNC</td><td>等待写完成（仅数据）</td></tr><tr><td>O_RSYNC</td><td>同时读写</td></tr><tr><td>O_FSYNC</td><td>等待写完成</td></tr><tr><td>O_ASYNC</td><td>异步I/O</td></tr><tr><td>O_TRUNC</td><td>截断文件，重头再来</td></tr><tr><td>O_CREAT</td><td>创造</td></tr></tbody></table><p>几个签名：</p><p><code>int open(const char * pathname, int flags, mode_t mode);</code></p><p>返回文件描述符</p><p>例如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> fd;  </span><br><span class="line">    fd=open(<span class="string">"abc"</span>,O_CREAT,<span class="number">0777</span>);  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fd=%d\n"</span>,fd);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ssize_t write(int fd, const void * buf, size_t count)</code></p><p>将存在buf中的写入fd指定的文件中，写入count个字节，返回写入的字节数。如果返回-1则出错</p><p><code>ssize_t read(int fd, void * buf, size_t count)</code></p><p>将fd指定的文件中的内容读到buf中，读count个字节，返回读出的字节数。如果返回-1则读出错</p><h3 id="第二道编程的题目跟进程和信号相关。要求详细掌握的用法包括：能用pause函数阻塞进程；能用signal设置信号处理函数；能向特定进程发送信号；能用rename移动文件；能遍历目录；能用S-ISREG宏辨别文件类型等等。切记对最后两道编程的大题要提前做好准备"><a href="#第二道编程的题目跟进程和信号相关。要求详细掌握的用法包括：能用pause函数阻塞进程；能用signal设置信号处理函数；能向特定进程发送信号；能用rename移动文件；能遍历目录；能用S-ISREG宏辨别文件类型等等。切记对最后两道编程的大题要提前做好准备" class="headerlink" title="第二道编程的题目跟进程和信号相关。要求详细掌握的用法包括：能用pause函数阻塞进程；能用signal设置信号处理函数；能向特定进程发送信号；能用rename移动文件；能遍历目录；能用S_ISREG宏辨别文件类型等等。切记对最后两道编程的大题要提前做好准备"></a>第二道编程的题目跟进程和信号相关。要求详细掌握的用法包括：能用pause函数阻塞进程；能用signal设置信号处理函数；能向特定进程发送信号；能用rename移动文件；能遍历目录；能用S_ISREG宏辨别文件类型等等。切记对最后两道编程的大题要提前做好准备</h3><p><code>int pause()</code> 使调用进程睡眠，直到接收到信号。<code>pause</code>返回-1，<code>errno</code>设置为EINTR</p><p><code>void (*signal(int signo, void (*func)(int)))(int)</code></p><p>第一个参数使调整的信号，第二个参数是一个函数，这个函数的参数是信号</p><p>打开目录通过</p><p><code>DIR * opendir(const char* name);</code></p><p>打开目录通过</p><p><code>struct dirent * readdir(DIR *dir);</code></p><p>返回一个struct dirent *类型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span>&#123;</span></span><br><span class="line"><span class="keyword">ino_t</span> dino; <span class="comment">//inode number</span></span><br><span class="line">    <span class="keyword">off_t</span> d_off; <span class="comment">//offset to the next dirent</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> d_reclen <span class="comment">//length of this record</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> d_type; <span class="comment">//type of file</span></span><br><span class="line">    <span class="keyword">char</span> d_name[<span class="number">256</span>]; <span class="comment">//name of the file</span></span><br></pre></td></tr></table></figure><p>关闭文件夹</p><p><code>int closedir(DIR * dir)</code></p><p>注意：遍历目录的时候要把上一级和目录以及隐藏文件去掉，避免死循环遍历</p><p>用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">strncmp</span>(file-&gt;d_name, <span class="string">"."</span>, <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整体大概是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">trave_dir</span><span class="params">(<span class="keyword">char</span> *path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DIR *d; <span class="comment">//声明一个句柄</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">file</span>;</span> <span class="comment">//readdir函数的返回值就存放在这个结构体中</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">sb</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(d = opendir(path)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"error opendir %s!!! \n"</span>, path);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ((file = readdir(d)) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        stat(file-&gt;d_name, &amp;sb);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(S_ISREG(sb.st_mode))</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"yes, this is a regular file: "</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s \n"</span>, file-&gt;d_name);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    closedir(d);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    trave_dir(<span class="string">"."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在我的cmake-build-debug文件夹下它ls的结果是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ls -al</span><br><span class="line"></span><br><span class="line">drwxrwxr-x 3 kardel kardel  4096 Jun 15 20:04 .</span><br><span class="line">drwxrwxr-x 4 kardel kardel  4096 Jun 15 20:04 ..</span><br><span class="line">-rw-rw-r-- 1 kardel kardel 44891 May 28 05:58 CMakeCache.txt</span><br><span class="line">drwxrwxr-x 5 kardel kardel  4096 Jun 15 20:04 CMakeFiles</span><br><span class="line">-rw-rw-r-- 1 kardel kardel  1539 May 28 05:58 cmake_install.cmake</span><br><span class="line">-rw-rw-r-- 1 kardel kardel  5149 Jun 15 19:49 Makefile</span><br><span class="line">-rw-rw-r-- 1 kardel kardel    12 Jun 15 19:24 test.txt</span><br><span class="line">-rwxrwxr-x 1 kardel kardel 12344 Jun 15 20:04 untitled</span><br><span class="line">-rw-rw-r-- 1 kardel kardel  5536 Jun 15 19:49 untitled.cbp</span><br></pre></td></tr></table></figure><p>我的程序输出是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">yes, this is a regular file: Makefile </span><br><span class="line">yes, this is a regular file: untitled.cbp </span><br><span class="line">CMakeFiles </span><br><span class="line">.. </span><br><span class="line">yes, this is a regular file: CMakeCache.txt </span><br><span class="line">yes, this is a regular file: untitled </span><br><span class="line">yes, this is a regular file: test.txt </span><br><span class="line">yes, this is a regular file: cmake_install.cmake </span><br><span class="line">.</span><br></pre></td></tr></table></figure></p><p>rename移动文件</p><p><code>int rename(const char * oldpath, const char * newpath);</code></p><p>如果出错，返回-1</p><table><thead><tr><th>宏</th><th>描述</th></tr></thead><tbody><tr><td>S_ISLNK</td><td>是否为一个链接</td></tr><tr><td>S_ISREG</td><td>是否为一个常规文件</td></tr><tr><td>S_ISDIR</td><td>是否为一个目录</td></tr><tr><td>S_ISCHR</td><td>是否为一个字符串特殊文件</td></tr><tr><td>S_ISBLK</td><td>是否为一个块特殊文件</td></tr><tr><td>S_ISFIFO</td><td>是否为FIFO文件</td></tr><tr><td>S_ISSOCK</td><td>是否为一个socket文件</td></tr></tbody></table><p>这些都可以通过</p><p><code>int stat(const char * restrict pathname, struct stat * restrict buf);</code></p><p><code>int fstat(int fd, struct stat * buf);</code></p><p>所得到的stat结构体中的<code>st_mode</code>得到。他的类型是<code>mode_t</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">buf</span>;</span></span><br><span class="line">    <span class="keyword">int</span> result = stat(<span class="string">"../test.c"</span>, &amp;buf);</span><br><span class="line">    <span class="keyword">if</span>(result == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(S_ISREG(buf.st_mode))</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"yes, it is a regular file"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"this is not a reg file!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"read error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yes, it is a regular file</span><br></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>有同校交友的吗……我的QQ号是1114599115，有没有小姐姐来加好友啊，我好寂寞啊~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;苦逼本科生要考试，考试还奇难内容齐多&lt;/p&gt;
&lt;p&gt;这里我整理一下考试提纲&lt;/p&gt;
&lt;p&gt;正好这也是对《unix环境高级编程》的前半部分的一
      
    
    </summary>
    
    
      <category term="unix" scheme="http://ChenKardel.github.io/tags/unix/"/>
    
      <category term="课程复习" scheme="http://ChenKardel.github.io/tags/%E8%AF%BE%E7%A8%8B%E5%A4%8D%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>通过深度学习增强药药反应和药食反应的预测效果</title>
    <link href="http://ChenKardel.github.io/2018/06/02/%E9%80%9A%E8%BF%87%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%A2%9E%E5%BC%BA%E8%8D%AF%E8%8D%AF%E5%8F%8D%E5%BA%94%E5%92%8C%E8%8D%AF%E9%A3%9F%E5%8F%8D%E5%BA%94%E7%9A%84%E9%A2%84%E6%B5%8B%E6%95%88%E6%9E%9C/"/>
    <id>http://ChenKardel.github.io/2018/06/02/通过深度学习增强药药反应和药食反应的预测效果/</id>
    <published>2018-06-02T09:34:48.000Z</published>
    <updated>2018-06-02T09:37:21.881Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>还是不要不务正业了，重新回到DDI的怀抱之中。（笑）</p><p>这篇是PNAS（美国科学院）的论文，还是有点分量的……虽然我觉得有点水</p><p>本篇文章主要讲的是基于深度学习的药物副作用与药物宇食物的作用的预测。</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>药与药(drug-drug interaction，DDI)，药与食物(drug-food constituent interaction，DFI)之间会产生极其大的反应，其中有很多恶性的反应（adverse drug events, ADE)，也有良性的反应。我们药减少恶性的反应并且增加良性的反应。</p><p>作者主要描述了基于深度学习的DDI和DFI的预测，模型名为DeepDDI。</p><h2 id="方法与实验"><a href="#方法与实验" class="headerlink" title="方法与实验"></a>方法与实验</h2><p>作者使用了深度学习的方法进行DDI的预测，将DDI作为86类分类器（具体哪八十六类，可以参考<a href="http://www.pnas.org/content/suppl/2018/04/14/1803294115.DCSupplemental" target="_blank" rel="noopener">deep-ddi所有数据文件</a>的dataset-S01）。<br><img src="/2018/06/02/通过深度学习增强药药反应和药食反应的预测效果/structure.bmp" alt="structure"></p><p>上图是模型主要架构</p><p><img src="/2018/06/02/通过深度学习增强药药反应和药食反应的预测效果/preprocess.bmp" alt="preprocess"></p><p>可以看见，将药物的SMILES（simplified molecular-input line-entry system，简化分子线性输入规范，用于描述一个化学物质的结构）输入，并且可以生成SSP（structural similarity profile，药物的特征向量，可以描述给定药物的独特结构特征）</p><p>ps：SSP我google+百度了半天没查到，可能SSP是他们原创的方法</p><p><img src="/2018/06/02/通过深度学习增强药药反应和药食反应的预测效果/pca.bmp" alt="pca"></p><p>SSP可以对某个单独的药物描述结构性特征。计算方法是与所有的2159个DrugBank中的药物的ECFP4（<a href="https://docs.chemaxon.com/display/docs/Extended+Connectivity+Fingerprint+ECFP#ExtendedConnectivityFingerprintECFP-morganref" target="_blank" rel="noopener">illustration of ECFP4</a>）经行比对。通过计算对每个药物的ECFP4的Tanimoto系数$T(A,B)={A\cdot B\over |A|^2+|B|^2-A\cdot B}$来算出SSP。</p><p>ECFP4使用Python库RDKit计算的。</p><p>计算出SSP之后，再使用PCA将SSP向量降维到50维。最后将两个50维的PCA输入到DNN中进行多分类。</p><p>ps: 作者再这里说PCA降维到10、20、30、40、50维都试验过，最终确定了50维是最好的</p><p>DNN我不用多说，注意输入为100维，代表了两种药物PCA降维后的维数和。输出有86种，代表了86类的多分类器。设置了一个阈值，超过这个阈值者就算作有这一类 ，设为1；否则设为0。最优的阈值维0.47</p><p>隐藏层的激活函数是ReLU，输出层的激活函数是sigmoid</p><p>用了Batch Normalization</p><p>Loss function是交叉熵</p><p>优化方法是Adam算法</p><p>代码层面用了Keras + Tensorflow后台</p><p>注意使用了<strong>GTX1080GPU</strong>运算（其实没啥……就是想到我那破1060就想哭）</p><p>训练还是老套路60%，20%，20%的分配，跑100次</p><p>DeepDDI最终可以生成人类可读的语句。</p><p>比如</p><p>羟考酮（oxycodone，阿片类止痛药）与阿扎那韦（atazanavir，抗转录药物）的反应会被描述成</p><p>“与阿扎那韦共同作用时，羟考酮的代谢效应会减少”</p><p>“当阿扎那韦与羟考酮共同作用时，不利反应的严重性或概率会增加”</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>较之间的运算方法，DeepDDI有很多优点，比如：</p><ol><li>其他的很多计算方法并没有很好的描述药与药之间的反应，而DeepDDI可以输出人类可读的语句。</li><li>其他的很多计算方法需要极其详细的药物信息就比如说药物的靶，有反应的药物，副作用。而DeepDDI是基于SMILES的方法，需要的信息比较单一</li><li>DeepDDI的精度极高，大约92%</li><li>SSP比两种最好的向量生成方法（Molecular Autoencoder, Mol2vec）都更加精确</li></ol><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol><li>神经网络的可解释性不强</li></ol><p>##相关的工作</p><p>之前也有基于Deep Learning的DDI的工作。</p><p><a href="https://www.researchgate.net/publication/292590022_Drug-Drug_Interaction_Extraction_via_Convolutional_Neural_Networks" target="_blank" rel="noopener">Drug Drug interaction extraction via convolutional nerual network</a></p><p><a href="https://arxiv.org/abs/1705.03261" target="_blank" rel="noopener">Drug-drug Interaction Extraction via Recurrent Neural Network with  Multiple Attention Layers</a></p><p><a href="http://xueshu.baidu.com/s?wd=paperuri%3A%282e9868021c33c158792dbd97f7d74bbd%29&amp;filter=sc_long_sign&amp;tn=SE_xueshusource_2kduw22v&amp;sc_vurl=http%3A%2F%2Fwww.ncbi.nlm.nih.gov%2Fpmc%2Farticles%2FPMC5751524%2Fpdf%2F12859_2017_Article_1962.pdf&amp;ie=utf-8&amp;sc_us=8702312857461780960" target="_blank" rel="noopener">Dependency-based long short term memory network for drug-drug interaction extraction</a></p><p>与本篇不同的是，这些工作很多事基于复杂网络研究的DDI，而本文可以说是基于相识度（化学成分结构）的DDI。</p><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>使用的数据是gold standard DDI dataset from DrugBank（<a href="http://www.pnas.org/content/suppl/2018/04/14/1803294115.DCSupplemental" target="_blank" rel="noopener">deep-ddi所有数据文件</a>的dataset-S02），包含了192284种DDI反应</p><p>虽然这个并不是输出一个one-hot向量，但是其实只有406(0.2%)的药物与药物对被检测有两种及以上的反应，而191472(99.8%)的药物与药物对之间只有一种反应。（PS：可不可以最后输出的时候用Softmax而不是Sigmoid，因为只有0.2%的多种反应）</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>原文给出了起码三个应用场景</p><ul><li>在gold standard DDI dataset中我们发现只有14种DDI类别是明确的有害的类别，其他的DDI情况不明或者是依赖药物施用环境。因此如果我们使用了某种药物（比如用环磷酰胺去治疗癌症）我们可以通过替换他的对应的拥有同样药理效果的药物（贝利司他，氨羟二磷酸二钠，苏灵大）去减少副作用（心脏中毒的概率）。</li><li>我们可以通过DDI的类型去判断药物是否有“恶性副作用”。如果DNN输出的类型小于阈值0.47，则就视为没有</li><li>我们可以用于判断药物与食物成分的共同作用（DFI）。一些特定的食物会减少一些药物的效果。就比如说，治疗高血压的三十个药物的体内浓度（这里翻译不好……意会，意会）可以被潜在的食物成分，比如左旋谷氨酸、左谷酰胺、 亚精胺，减少。多价正离子，比如$Al^{3+}$、$Mg^{2+}$，可以造成药物的治疗失败。</li></ul><h2 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h2><ol><li>三及多个药物的DDI并没有研究——造成无法研究的原因是数据库的缺乏（如果有这样的数据库的话我认为用RNN/LSTM/GRU可以解）</li><li>DeepDDI的可解释性有待研究（Deep learning的原罪……）</li><li>很多其他的数据，比如转录组数据可以被使用</li></ol><h2 id="我的想法"><a href="#我的想法" class="headerlink" title="我的想法"></a>我的想法</h2><ol><li>PCA有没有更好的解决方案？能不能用其他的方法（比如构造自编码器之类的（瞎编））代替PCA</li><li>DNN的改善方法？可不可以想其他的网络而不是MLP？</li><li><strong>讨论</strong>中的一些问题还有可进步的地方</li><li>代码我暂时没看，RDKit很难配，可能根据代码出一篇博客</li><li>看不懂的化学生物问题不要紧，我也不懂（逃ε=ε=ε=┏(゜ロ゜;)┛）</li><li>这篇的一个特点就是它是基于化学结构与成分的Deep learning based DDI，而不是基于复杂网络的DDI</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;还是不要不务正业了，重新回到DDI的怀抱之中。（笑）&lt;/p&gt;
&lt;p&gt;这篇是PNAS（美国科学院）的论文，还是有点分
      
    
    </summary>
    
    
      <category term="深度学习" scheme="http://ChenKardel.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="二十一世纪科学（滑稽）" scheme="http://ChenKardel.github.io/tags/%E4%BA%8C%E5%8D%81%E4%B8%80%E4%B8%96%E7%BA%AA%E7%A7%91%E5%AD%A6%EF%BC%88%E6%BB%91%E7%A8%BD%EF%BC%89/"/>
    
  </entry>
  
  <entry>
    <title>Pix2pix:基于条件对抗网络图对图翻译</title>
    <link href="http://ChenKardel.github.io/2018/06/02/Pix2pix-%E5%9F%BA%E4%BA%8E%E6%9D%A1%E4%BB%B6%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C%E5%9B%BE%E5%AF%B9%E5%9B%BE%E7%BF%BB%E8%AF%91/"/>
    <id>http://ChenKardel.github.io/2018/06/02/Pix2pix-基于条件对抗网络图对图翻译/</id>
    <published>2018-06-02T09:30:06.000Z</published>
    <updated>2018-06-02T10:30:33.704Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Pix2pix-基于条件对抗网络图对图翻译"><a href="#Pix2pix-基于条件对抗网络图对图翻译" class="headerlink" title="Pix2pix:基于条件对抗网络图对图翻译"></a>Pix2pix:基于条件对抗网络图对图翻译</h1><p>我现在正在研究GAN，GAN也正是我的兴趣方向之一。</p><p>本篇要讲的是pix2pix，讲道理，那个网页版我可以玩一年</p><p><a href="https://phillipi.github.io/pix2pix/" target="_blank" rel="noopener">Pix2pix官网</a></p><p><a href="https://arxiv.org/pdf/1611.07004.pdf" target="_blank" rel="noopener">pix2pix论文</a></p><p><a href="https://github.com/phillipi/pix2pix" target="_blank" rel="noopener">Pix2pix的github</a></p><p>（注：原代码是用torch写的，但是作者也在官网提供了tensorflow版和pytorch版。起码不用面对lua这个语言）</p><p><img src="/2018/06/02/Pix2pix-基于条件对抗网络图对图翻译/header.bmp" alt="header"></p><h2 id="图像翻译"><a href="#图像翻译" class="headerlink" title="图像翻译"></a>图像翻译</h2><p>“翻译”常用于语言之间的翻译，就比如中文和英文的之间的翻译。但是图像翻译的意思是以不同形式在图与图之间转换。比如，一张场景可以转换为RGB全彩图，也可以转化成素描，也可以转化为灰度图。一张夜景图也可以转化为这个地方的日景图。</p><p>传统的来说，每一种转换，比如从灰度图到素描，或者从素描到灰度图，都是需要一种特定的算法。而Pix2pix的目标就是建立一个通用的架构去解决所有的这些问题。</p><p>自编码器与CNN，为了使loss function更小而不得不使生成出来的图片模糊。这些对loss function有益的行为最终导致的是生成很假的图片（讲个道理，模糊的原因与很多自编码器采取sigmoid有没有关系？笔者觉得使用leaky relu可能会减少模糊，但是笔者试过，效果不算好）GAN提供了一种生成精准图片的方法，原因是识别网络完全能判断出模糊的图像是假图。</p><p>这在里，作者使用了条件GAN（cGAN）去学习一个条件生成模型。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><p>cGAN的损失可以表达为：</p><p><img src="/2018/06/02/Pix2pix-基于条件对抗网络图对图翻译/f1.png" alt="f1"></p><p>可以看出，较普通的GAN来说，cGAN的生成网络监听了输入x。</p><p>普通的GAN的形式是</p><p><img src="/2018/06/02/Pix2pix-基于条件对抗网络图对图翻译/f2.png" alt="f2"></p><p>可以明显看出，这个形式的生成网络不需要输入x</p><p>研究表明如果给GAN加上一个传统距离（regularization?），比如L2，GAN的表现更好。而Pix2pix使用的是L1架构，可以减少模糊程度</p><p><img src="/2018/06/02/Pix2pix-基于条件对抗网络图对图翻译/f3.png" alt="f3"></p><p>所以最终的loss function是</p><p><img src="/2018/06/02/Pix2pix-基于条件对抗网络图对图翻译/f4.png" alt="f1"></p><p>原版GAN中的噪音noise，在这里变成了dropout形似的</p><p>###网络架构</p><h4 id="生成网络：U-net"><a href="#生成网络：U-net" class="headerlink" title="生成网络：U-net"></a>生成网络：U-net</h4><p>由于是个conditional GAN，这个生成者是个自编码器（输入一张图片大小，输出一张图片大小）。但是较传统用自编码器的写法不同，作者使用了U-Net<br><img src="/2018/06/02/Pix2pix-基于条件对抗网络图对图翻译/Unet.bmp" alt="Unet"></p><p>U-Net的论文具体可以看</p><p><a href="https://arxiv.org/pdf/1505.04597.pdf" target="_blank" rel="noopener">U-Net: Convolutional Networks for Biomedical Image Segmentation</a></p><p>这篇论文（虽然我没看（逃））</p><p>U-Net在Autoencoder的基础上，使用了skip-connection。这么做的原因在于很多网络需要讲input的低阶信息分享给output。</p><p>skip-connection的特点在于将decoder和encoder连接起来。貌似与ResNet的链接有一定相像，都是相加（不确定，如果有大佬矫正的话请评论）。从上图也可以看到U-net的架构。</p><h4 id="识别网络-PatchGAN"><a href="#识别网络-PatchGAN" class="headerlink" title="识别网络: PatchGAN"></a>识别网络: PatchGAN</h4><p>L2 损失比L1损失更加容易产生模糊效益。所以在网络架构上我们会采取L1去解决问题。</p><p>因为我们已经可以通过L1获取低频的结构，我们想要获取高频出现的架构。于是我们采取了PatchGAN的架构。PatchGAN只会去判定每一个每一个小的$N*N$的Patch中的结构是真或假并且惩罚它。并且计算平均数作为最终的结果。</p><p>这是个马尔科夫过程，也可以理解为风格损失（局部的）</p><h4 id="优化和推断"><a href="#优化和推断" class="headerlink" title="优化和推断"></a>优化和推断</h4><p>优化没啥可说的，mini batch SGD</p><p>推断注意使用了dropout和batch normalization。training batch 被设为1，这个操作被叫做“instance normalization”</p><h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h3><p>一般为了效率我不喜欢看Experiment部分……很多Experiment都是作者自己吹比……但是这个Experiment不知道有多劲爆……</p><h4 id="评价标准"><a href="#评价标准" class="headerlink" title="评价标准"></a>评价标准</h4><p>两种手法</p><ol><li><p>Amazon  Mechanical Turk（AMT）</p><p>这个……感觉事50个Turker去评价算法生成……</p><p>感觉这个是真人评价……有点屌……</p></li><li><p>FCN-score</p><p>是采用的语言分段的算法做的评价</p></li></ol><p>一些实验的结论：</p><ol><li><p>生成网络：U-Net的效果是最好的</p></li><li><p>识别网络：L1+cGAN的效果比L1/L1+GAN/cGAN/GAN都好</p></li><li><p>PatchGAN的N：在70的时候表现是最好的</p><p><img src="/2018/06/02/Pix2pix-基于条件对抗网络图对图翻译/patchGAN.bmp" alt="patchGAN"><br>可以看出在$1<em>1$–&gt;$16</em>16$的趋势下图像越来越清晰，并且FCN-score逐渐增高，颜色以越来越相近，到$70<em>70$打到顶峰。但是较$70</em>70$，$286<em>286$的画质非常差而且FCN-score非常低。可能是由于$286</em>286$需要太多参数，训练复杂</p></li></ol><p>顺便提一点，这个网络的目的不是与输入图相同，而是做出一个以假乱真的假图，所以不会与原图经行任何比对。可以说生成图和原图是独立的。</p><p>在颜色上，L1会使图像便暗（我的理解是L1的稀疏性会使图像朝变暗的趋势靠拢），而cGAN完全没有这个问题。所以L1+cGAN可以保持生成图片颜色的鲜艳。</p><p>最后就是这个网络的结果，非常有意思<br><img src="/2018/06/02/Pix2pix-基于条件对抗网络图对图翻译/result1.bmp" alt="result1"><br>还有我自己画的“猫”（我知道有点吓人……）<br><img src="/2018/06/02/Pix2pix-基于条件对抗网络图对图翻译/result2.bmp" alt="result2"><br><img src="/2018/06/02/Pix2pix-基于条件对抗网络图对图翻译/result3.bmp" alt="result3"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Pix2pix-基于条件对抗网络图对图翻译&quot;&gt;&lt;a href=&quot;#Pix2pix-基于条件对抗网络图对图翻译&quot; class=&quot;headerlink&quot; title=&quot;Pix2pix:基于条件对抗网络图对图翻译&quot;&gt;&lt;/a&gt;Pix2pix:基于条件对抗网络图对图翻译&lt;/
      
    
    </summary>
    
    
      <category term="深度学习" scheme="http://ChenKardel.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="论文解析" scheme="http://ChenKardel.github.io/tags/%E8%AE%BA%E6%96%87%E8%A7%A3%E6%9E%90/"/>
    
      <category term="计算机视觉" scheme="http://ChenKardel.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
  </entry>
  
  <entry>
    <title>DeLiGAN: 对于多样性和有限数据的GAN</title>
    <link href="http://ChenKardel.github.io/2018/06/02/DeLiGAN-%E5%AF%B9%E4%BA%8E%E5%A4%9A%E6%A0%B7%E6%80%A7%E5%92%8C%E6%9C%89%E9%99%90%E6%95%B0%E6%8D%AE%E7%9A%84GAN/"/>
    <id>http://ChenKardel.github.io/2018/06/02/DeLiGAN-对于多样性和有限数据的GAN/</id>
    <published>2018-06-02T09:21:32.000Z</published>
    <updated>2018-06-02T09:33:32.170Z</updated>
    
    <content type="html"><![CDATA[<p>开始遨游CVPR2017，主要是为了学习更多的深度学习网络架构</p><p>讲道理计算机视觉的深度学习架构是深度学习各领域比较先进的，比如CNN，自编码器，GAN，注意力机制都是出于CV然后应用于其他领域的。所以即使我不学CV了还是要看CVPR的论文</p><p>论文本身</p><p><a href="http://openaccess.thecvf.com/content_cvpr_2017/papers/Gurumurthy_DeLiGAN__Generative_CVPR_2017_paper.pdf" target="_blank" rel="noopener">DeLiGAN</a></p><ol><li><p>讨论一下GAN的缺点:</p></li><li><p>Mode Collapse：当GAN无法达到识别网络D每趟的运行次数大于生成网络G的时候，生成网络生成的所有内容都将归于同样的对象，比如训练GAN for MNIST最后所有的生成内容都为1</p></li><li><p>训练速度慢，训练吃数据：原始GAN的生成网络与识别网络都是MLP（不是很懂为什么）。较CNN来说，MLP更吃数据而且运行速度更慢</p></li><li><p>GAN生成数据的多样性来自于GAN的生成者输入的噪音N。原始GAN的噪音是高斯噪音。而这篇文章主要的重点，笔者认为在于尝试去用一个有点想Batch Normalization的方式去学习噪声输入<img src="/2018/06/02/DeLiGAN-对于多样性和有限数据的GAN/strcutureGAN.bmp" alt="strcutureGAN"></p></li></ol><p>图右就是DeLiGAN的结构。可以看到，DeLiGAN在输入的时候进行了变化。</p><p>DeLiGAN使输入噪音通过一个高斯混合模型（Mixture-of-Gaussian model）</p><p>$$p_z(z) = \sum_{i=1}^N\phi_ig(z|\mu_i, \Sigma)​$$</p><p>其中$\phi_i$是权值，也是采用重参数单元（我使用的是指的是$g(z|\mu_i, \Sigma)$ ）的概率。在文章中$\phi$ 使用的是uniform概率，即原公式变为</p><p>$p_z(z) = \sum_{i=1}^N\frac{g(z|\mu_i, \Sigma)}{N}$</p><p>我们随机的从N个重参数单元中选取一个，每一个选取概率相同</p><p>假设第$i$个单元被选择。我们将输入重新定义为</p><p>$z = \mu_i+\sigma_i \epsilon where \epsilon \sim N(0, 1)$    </p><p>将其代入GAN的模型，可以将原模型变为：</p><p>$p_{data}(G(z))=\sum_{i=1}^N\int\frac{p_{data}(G(\mu_i+\sigma_i\epsilon |\epsilon))p(\epsilon)d\epsilon}{N}$</p><p>其中$\mu$ 和$\sigma$ 都是应该学习的参数</p><p>3.学习$\mu$与$\sigma$</p><p>notice：作者说明为什么不试着在单元的地方使用权值参数：因为无法正常训练，无法得到权值的梯度</p><p>由于$p_{data}(G(z))$在$\mu_i$处有局部最小值，所以当G优化$\sigma$ 的时候，$\sigma$可以小于0。为了避免这个，我们尝试在GAN网络                  基础上用L2正则化</p><p>$max_GV_G(D, G)=min_G\mathbb{E}_{z\sim p_z}[log(1-D(G(z)))]+\lambda\sum_{i=1}^N\frac{(1-\sigma_i)^2}{N}$</p><ol start="4"><li>实验</li></ol><p>这个论文实验最有意思的地方在于他对不同的数据库用不同的架构<img src="/2018/06/02/DeLiGAN-对于多样性和有限数据的GAN/differentArc.bmp" alt="differentArc"></p><p>可以看出，他用了Inceptive的结构，这对于某些网络结构有非常好的效果。</p><p><img src="/2018/06/02/DeLiGAN-对于多样性和有限数据的GAN/result.bmp" alt="result"></p><p>从h-m中看出，效果大概比GAN好（j-m是它定义的一些架构，就不描述了）</p><ol start="5"><li>我的想法</li></ol><p>我觉得……还行吧，暂时没有运行过。整体比较玄学，并没有解释为什么这个设计好与好在哪，我只能说输入从普通的高斯噪音变成了加强版的高斯输出</p><p>我认为单元的设计有点像Dropout + ensemble。</p><p>我懂为什么对多样性有帮助，但是并不是很懂对limited data有什么帮助</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;开始遨游CVPR2017，主要是为了学习更多的深度学习网络架构&lt;/p&gt;
&lt;p&gt;讲道理计算机视觉的深度学习架构是深度学习各领域比较先进的，比如CNN，自编码器，GAN，注意力机制都是出于CV然后应用于其他领域的。所以即使我不学CV了还是要看CVPR的论文&lt;/p&gt;
&lt;p&gt;论文本
      
    
    </summary>
    
    
      <category term="深度学习" scheme="http://ChenKardel.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="论文解析" scheme="http://ChenKardel.github.io/tags/%E8%AE%BA%E6%96%87%E8%A7%A3%E6%9E%90/"/>
    
      <category term="计算机视觉" scheme="http://ChenKardel.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
  </entry>
  
  <entry>
    <title>神经网络实践经验(4)</title>
    <link href="http://ChenKardel.github.io/2018/06/02/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E7%BB%8F%E9%AA%8C-4/"/>
    <id>http://ChenKardel.github.io/2018/06/02/神经网络实践经验-4/</id>
    <published>2018-06-02T09:15:07.000Z</published>
    <updated>2018-06-02T09:19:16.208Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>地铁上无聊码的，思路比较凌乱</p><ol start="4"><li>现代神经网络的目标</li></ol><p>我认为，现代神经网络的目标只有两个</p><ol><li><p>过拟合与欠拟合的调试</p></li><li><p>internal covariance shift<br>过拟合和欠拟合的调试</p></li></ol><p>神经网络的过拟合与欠拟合一直是个恒古不变的话题</p><p>如何能够防止神经网络产生没意义的特征工程和做出有意义的特征工程，就是这方面的一个问题</p><p>mlp擅长过拟合，因为他会提取完全无关系的神经元之间的关系并作为特征。而局部连接的一些神经网络可以减少这样的操作。</p><p>但cnn也不是完全都恰当好处的特征提取，所以在架构与架构之间产生非常大的差别，nin和alexnet的参数数量可以差十倍却有差不多的效果</p><p>神经网络都追求较少的参数，也是希望减少过拟合</p><p>与传统机器学习方法不同，神经网络增加模型容量可谓是简单至极。你希望的话，可以把cnn叠个一万层</p><p>分分钟过拟合</p><p>所以大部分情况下都是在解决过拟合问题</p><p>很多网络架构都在探究用最少的参数做出最好的效果，即减少过拟合程度，也是如此</p><h2 id="internal-covariance-shift"><a href="#internal-covariance-shift" class="headerlink" title="internal covariance shift"></a>internal covariance shift</h2><p>（不是很会翻这个词，内部协变量转移？一下简称ics了）</p><p>（一点注意的是ics和covariance shift不同。covariance指的是模型在testing和training集的差，而ics就是梯度爆炸和梯度消失神马的）</p><p>ics：the change during training due to the change in parameters（《batch normalization》）</p><p>我擅自将其解释为类似梯度爆炸和梯度消失的问题</p><p>这是我第一次看到这个词的定义</p><p>但是相似描述的情景在densenet和resnet的论文中也有描述</p><p>过深的网络不好训练，训练的结果也不太好</p><p>现代很多网络的研究就在于解决这个问题</p><p>batch normalization通过标准化来解决这个问题，同时用两个可学习的参数去减轻标准化对特征的破坏</p><p>densenet和resnet都通过较远的神经元的连接的方式去减轻这个问题</p><p>当然resnet和densenet思路有点小不同</p><p>resnet想学习的是ΔW</p><p>densenet疯狂地追求前后连接</p><p>但本质差不多（densenet如是说）</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本文只是一个大二学生的粗鄙之语</p><p>自己还是论文看少了</p><p>比如resnet和densenet都提到的一个f什么net我就没看</p><p>还有其实很多问题，神经网络也不像我说的这么简单</p><p>就当以上内容纯属虚构和胡说八道吧</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;地铁上无聊码的，思路比较凌乱&lt;/p&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;现代神经网络的目标&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我认为，现代神经
      
    
    </summary>
    
    
      <category term="深度学习" scheme="http://ChenKardel.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="神经网络实践经验" scheme="http://ChenKardel.github.io/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>神经网络实践经验(3)</title>
    <link href="http://ChenKardel.github.io/2018/06/02/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E7%BB%8F%E9%AA%8C-3/"/>
    <id>http://ChenKardel.github.io/2018/06/02/神经网络实践经验-3/</id>
    <published>2018-06-02T09:13:42.000Z</published>
    <updated>2018-06-02T09:18:56.308Z</updated>
    
    <content type="html"><![CDATA[<h2 id="3-慎用keras的binary-crossentropy"><a href="#3-慎用keras的binary-crossentropy" class="headerlink" title="3. 慎用keras的binary_crossentropy"></a>3. 慎用keras的binary_crossentropy</h2><p>有的时候我们在用神经网络训练二分类模型的时候，我们常会用keras。keras关于二分类的loss function有两个，一个是binary_crossentropy，一个是categorical_crossentropy（其实是多分类）。但是据本人实测，用binary_ceossentropy的训练效果非常差，几乎训练不出东西，所以暂时推荐使用categorical_crossentropy</p><p>至于为什么我也不知道，可能和内部写法有关但是我也没看keras内部实现</p><p>没有调查就没有发言权，对吧</p><p>所以先占个坑，知道了再补</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;3-慎用keras的binary-crossentropy&quot;&gt;&lt;a href=&quot;#3-慎用keras的binary-crossentropy&quot; class=&quot;headerlink&quot; title=&quot;3. 慎用keras的binary_crossentropy&quot;&gt;&lt;/
      
    
    </summary>
    
    
      <category term="深度学习" scheme="http://ChenKardel.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="神经网络实践经验" scheme="http://ChenKardel.github.io/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>神经网络实践经验(2)</title>
    <link href="http://ChenKardel.github.io/2018/06/02/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E7%BB%8F%E9%AA%8C-2/"/>
    <id>http://ChenKardel.github.io/2018/06/02/神经网络实践经验-2/</id>
    <published>2018-06-02T09:07:42.000Z</published>
    <updated>2018-06-02T09:18:56.269Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本人萌新，请多指教</p><h2 id="2-1x1卷积层的作用"><a href="#2-1x1卷积层的作用" class="headerlink" title="2. 1x1卷积层的作用"></a>2. 1x1卷积层的作用</h2><p>我们都知道，CNN强于MLP的地方在于其局部连接性减少了过拟合的可能，从而在有限的数据量下可以获取更好的模型。</p><p>而CNN是一个基于上下文的网络。对于上下文相关的数据（图像、自然语言等），有着非常理所应当、有理有据的好效果。但是如果filter的大小是1x1呢（本文只探讨2d的CNN，如果要强行说Conv1D我也没办法）?</p><p>1x1的filter貌似是上下文无关的。所以1x1的filter与3x3的filter和5x5的filter有着完全不一样的功能。</p><p>本萌新读的论文不多，但我记得1x1filter在VGG论文<a href="http://x-algo.cn/wp-content/uploads/2017/01/VERY-DEEP-CONVOLUTIONAL-NETWORK-SFOR-LARGE-SCALE-IMAGE-RECOGNITION.pdf" target="_blank" rel="noopener">VERY DEEP CONVOLUTIONAL NETWORKS FOR LARGE-SCALE IMAGE RECOGNITION</a>中出现过。VGG指出有1x1的卷积层（VGG的C号架构）物体识别效果比没有（VGG的B号架构）效果好，但是没有3x3的卷积层（VGG的D号架构）效果好。但是并没有给出解释。（顺便一提我认为VGG是ImageNet几篇中最水的一篇，全篇就是在说他用了谁的方法没用谁的方法然后做做做做做实验）</p><p>然后1x1的使用比较引起轰动就是在<a href="https://arxiv.org/pdf/1312.4400.pdf" target="_blank" rel="noopener">Network in Network</a>中。《Network in Network》整篇论文写的玄乎得要死，什么mlpconv啊什么得，但是实际上观察它得代码就会发现所谓得mlpconv就是1x1得卷积层。仔细想想也是那么回事，实际上1x1的filter由于卷积神经网络的操作已经可以退化为卷积层每个通道的加权求和，然后通过一层激活函数就和单层mlp无异。虽然3x3的卷积核也会有加权求和的操作，但是1x1的卷积核是脱离了上下文的加权求和操作，而3x3是带上下文的加权求和操作</p><p><img src="/2018/06/02/神经网络实践经验-2/nin.png" alt="Network in network"></p><p>再然后就是Inception中的降维1x1了，我可以将一个28x28x64的卷积层强行压到28x28x20的卷积层，既不增加很多参数数量又能减少卷积层的参数数量，还能加权求和一波，简直非常好用。</p><p><img src="/2018/06/02/神经网络实践经验-2/inception.png" alt="inception"></p><p>包括resNet中的先降维后升维的操作同理，既可以降低参数数量又可以保持x与F(x)形状不变，可以说是很棒了<img src="/2018/06/02/神经网络实践经验-2/C:/Users\11145\Desktop\bimg\resNet.png" alt="resNet"></p><p><img src="/2018/06/02/神经网络实践经验-2/resNet.png" alt="resnet"></p><p>所以总结一下，1x1的filter的作用是</p><ol><li>增加通道之间的交流</li><li>降维或升维</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本人萌新，请多指教&lt;/p&gt;
&lt;h2 id=&quot;2-1x1卷积层的作用&quot;&gt;&lt;a href=&quot;#2-1x1卷积层的作用&quot; class=&quot;heade
      
    
    </summary>
    
    
      <category term="深度学习" scheme="http://ChenKardel.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="神经网络实践经验" scheme="http://ChenKardel.github.io/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>神经网络实践经验(1)</title>
    <link href="http://ChenKardel.github.io/2018/06/02/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E7%BB%8F%E9%AA%8C-1/"/>
    <id>http://ChenKardel.github.io/2018/06/02/神经网络实践经验-1/</id>
    <published>2018-06-02T08:54:58.000Z</published>
    <updated>2018-06-02T09:18:27.029Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本系列是本人记录在自己实践中遇到的很多读死书无法学习到的经验，不完全脱离理论，甚至说是超过理论之外的东西。</p><p>本人水平很差（深度学习之耻），有些说的简陋的东西也当是献丑了。</p><h4 id="1-神经网络的输入最好有一定相关性，否则很容易产生过拟合的效果"><a href="#1-神经网络的输入最好有一定相关性，否则很容易产生过拟合的效果" class="headerlink" title="1. 神经网络的输入最好有一定相关性，否则很容易产生过拟合的效果"></a>1. 神经网络的输入最好有一定相关性，否则很容易产生过拟合的效果</h4><p>所谓的过拟合，就是模型学习到本应该学习到的特征之外的特征。</p><p><img src="/2018/06/02/神经网络实践经验-1/image1.bmp" alt="图一"></p><p>如图，本来模型只应该学习到x，$x^2$ 和常数项的特征，但是由于模型的容量（capacity）太大，模型学习到了$x^3$ 和$x^4$的特征。所以造成最后模型的扭曲。</p><p>过拟合的问题大家肯定都懂，模型在testing数据集和training数据集的差异会非常大，在training集上表现非常好的数据在testing集上会非常差。</p><p><img src="/2018/06/02/神经网络实践经验-1/image2.bmp" alt="图二"></p><p>在神经网络中最常用的正则化方法是Dropout。</p><p>同时我们应该去了解一下神经网络中的全连接层。全连接层在数据于数据之中找关系，提取输入数据的浅层特征与深层特征并且将这些特征映射到类别中（此处我只说的是多分类，其他的工作暂时不讲）。也就是说在全连接层中它寻找的输入每个神经元与神经元之间的联系。</p><p>从某种意义上来说，神经网络就是个高超的特征工程器。</p><p>在某些时候，我们为了去做多分类，会去试着去找无关（前置知识）的特征然后作为输入扔给神经网络。甚至是两个相互无关（前置知识）的向量拼接之后扔给神经网络。</p><p>不得不说，这是非常蠢的想法。</p><p>我们迫使神经网络去找到已知无关的数据的联系特征，这本身就可能然神经网络产生过拟合。</p><p>就比如，我现在用多层感知机(MLP)做推荐系统，有user向量<strong>u</strong>也有item向量<strong>i</strong> ，user和item没有直接关联，我们将<strong>u</strong>与<strong>i</strong>拼接并直接扔给MLP。MLP学习到了user的特征还有item的特征，还有……user中某个神经元和item某个神经元的联系。</p><p>单单用脑子想想就知道，我们会学习到很多在推荐系统中一点用都没有的特征，相当于神经网络瞎做特征工程，然后过拟合了，即时加了Dropout也没用。</p><p>为什么使用神经网络去处理图像的效果好？因为本身图像就是一个上下文相关的数据，很多像素点的集合不叫有意义的图像，像素点与像素点连接所构成的有意义的数据才能叫有意义的图像。但是图像本身是局部相关，我左下角的像素点可能和右上角的像素点一点关系都没有，但是左下角的像素点只与它周围一圈的像素点有关，所以CNN较MLP更适合Computer Vision。</p><p>NLP同理（虽然我不懂XD）。</p><p>这个时候我们应该做什么呢？</p><p>本人认为，应该试着使用CNN这种局部特征网络。并且可以试着在<strong>u</strong>和<strong>i</strong>拼接处加上少许的0（数量大概是filter的大小减一），这样可以杜绝overfit</p><p>当然你说你数据量大你头铁那我也没办法，毕竟在深度学习中数据量大是可以为所欲为的。</p><p>图片来源：</p><p><a href="https://blog.csdn.net/willduan1/article/details/53070777" target="_blank" rel="noopener">https://blog.csdn.net/willduan1/article/details/53070777</a></p><p>图书 deep learning</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本系列是本人记录在自己实践中遇到的很多读死书无法学习到的经验，不完全脱离理论，甚至说是超过理论之外的东西。&lt;/p&gt;
&lt;p&gt;本人水平很差（深度
      
    
    </summary>
    
    
      <category term="深度学习" scheme="http://ChenKardel.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="神经网络实践经验" scheme="http://ChenKardel.github.io/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%B7%B5%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
</feed>
