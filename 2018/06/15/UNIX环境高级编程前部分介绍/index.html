<!DOCTYPE html>
<html lang="z">
<head>
    <meta charset="utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    
    <title>UNIX环境高级编程前部分介绍 | Kardel的希尔伯特空间</title>
    <meta name="renderer" content="webkit">
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <meta name="description" content="浅度辍学集大成者
the man who masters shallow dropout">

    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="UNIX环境高级编程前部分介绍 | Kardel的希尔伯特空间">
    <meta name="twitter:description" content="浅度辍学集大成者
the man who masters shallow dropout">

    <meta property="og:type" content="article">
    <meta property="og:title" content="UNIX环境高级编程前部分介绍 | Kardel的希尔伯特空间">
    <meta property="og:description" content="浅度辍学集大成者
the man who masters shallow dropout">

    
    <meta name="author" content="kardel">
    
    <link rel="stylesheet" href="/css/vno.css">
    <link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css">

    
    <link rel="icon" href="/images/avatar-icon.png">
    

    <meta name="generator" content="hexo"/>
    
    <link rel="alternate" type="application/rss+xml" title="Kardel的希尔伯特空间" href="/atom.xml">
    

    <link rel="canonical" href="http://ChenKardel.github.io/2018/06/15/UNIX环境高级编程前部分介绍/"/>

                 
</head>

<body class="home-template no-js">
    <script src="//cdn.bootcss.com/jquery/2.1.4/jquery.min.js"></script>
    <script src="/js/main.js"></script>
    <span class="mobile btn-mobile-menu">
        <i class="fa fa-list btn-mobile-menu__icon"></i>
        <i class="fa fa-angle-up btn-mobile-close__icon hidden"></i>
    </span>

    
<header class="panel-cover panel-cover--collapsed" style="background-image: url(/images/background-cover.jpg)">
  <div class="panel-main">
    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        <a href="/" title="前往 Kardel的希尔伯特空间 的主页"><img src="/images/avatar.jpg" width="80" alt="Kardel的希尔伯特空间 logo" class="panel-cover__logo logo" /></a>
        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage for Kardel的希尔伯特空间">Kardel的希尔伯特空间</a></h1>
        
        <hr class="panel-cover__divider" />
        <p class="panel-cover__description">浅度辍学集大成者
the man who masters shallow dropout
</p>
        <hr class="panel-cover__divider panel-cover__divider--secondary" />

        <div class="navigation-wrapper">
          <div>
          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">
              <li class="navigation__item"><a href="/#blog" title="Visit the blog" class="blog-button">Blog</a></li>
            
              <li class="navigation__item"><a href="/aboutme">关于我</a></li>
            
            </ul>
          </nav>
          </div>
          <div>
          <nav class="cover-navigation navigation--social">
  <ul class="navigation">

  <!-- Weibo-->
  

  <!-- Github -->
  
  <li class="navigation__item">
    <a href="https://github.com/ChenKardel" title="GitHub" target="_blank">
      <i class='social fa fa-github'></i>
      <span class="label">Github</span>
    </a>
  </li>


<!-- Stack Overflow -->
        

  <!-- Google Plus -->
  

<!-- Facebook -->

  
<!-- Twitter -->

  

  <li class="navigation__item">
    <a href="/atom.xml" title="RSS" target="_blank">
      <i class='social fa fa-rss'></i>
      <span class="label">RSS</span>
    </a>
  </li>



  </ul>
</nav>

          </div>
        </div>

      </div>

    </div>

    <div class="panel-cover--overlay cover-purple"></div>
  </div> 
</header>

    <div class="content-wrapper">
        <div class="content-wrapper__inner">
            <article class="post-container post-container--single">

  <header class="post-header">
    <div class="post-meta">
      <time datetime="2018-06-15T13:25:02.000Z" class="post-list__meta--date date">2018-06-15</time> &#8226; <span class="post-meta__tags tags">于 
  <a class="tag-link" href="/tags/unix/">unix</a>, <a class="tag-link" href="/tags/课程复习/">课程复习</a>
 </span>
      <span class="page-pv">
       Read <span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span>
      </span> 
   
    </div>
    <h1 class="post-title">UNIX环境高级编程前部分介绍</h1>
  </header>

  <section class="post">
    <p>##前言</p>
<p>苦逼本科生要考试，考试还奇难内容齐多</p>
<p>这里我整理一下考试提纲</p>
<p>正好这也是对《unix环境高级编程》的前半部分的一个总结</p>
<p>就当看着乐</p>
<p>##正文</p>
<h4 id="什么是操作系统？什么是UNIX操作系统？什么是Linux操作系统？它们之间的关系是怎样的？"><a href="#什么是操作系统？什么是UNIX操作系统？什么是Linux操作系统？它们之间的关系是怎样的？" class="headerlink" title="什么是操作系统？什么是UNIX操作系统？什么是Linux操作系统？它们之间的关系是怎样的？"></a>什么是操作系统？什么是UNIX操作系统？什么是Linux操作系统？它们之间的关系是怎样的？</h4><p>操作系统是管理和控制计算机硬件和软件资源的计算机程序，是直接运行在“裸机”上的最基本的系统软件。</p>
<p>UNIX是一个与1969年在AT&amp;T的贝尔实验室开发的多用户多任务的分时的操作系统</p>
<p>Linux是一个基于POSIX和UNIX的多用户、多任务、支持多线程的开源的由Linus开发的操作系统</p>
<p>Linux是基于UNIX而构造的。</p>
<h4 id="UNIX操作系统有哪些典型的分支？"><a href="#UNIX操作系统有哪些典型的分支？" class="headerlink" title="UNIX操作系统有哪些典型的分支？"></a>UNIX操作系统有哪些典型的分支？</h4><p>Solaris，Linux，HP-UX，FreeBSD，SunOS，MacOS</p>
<h4 id="什么是Shell？内置变量-、-、-、-、-的具体含义是什么？"><a href="#什么是Shell？内置变量-、-、-、-、-的具体含义是什么？" class="headerlink" title="什么是Shell？内置变量$、$*、$@、$?、$#的具体含义是什么？"></a>什么是Shell？内置变量$、$*、$@、$?、$#的具体含义是什么？</h4><p><code>$$</code> 指当前shell进程的pid</p>
<p><code>$*</code>指的是传递给脚本的所有参数</p>
<p><code>$@</code>也是把所有参数传递给脚本，但是当参数被双引号包含的时候，<code>$*</code>会把所有的参数作为一个整体，而<code>$@</code>会将各个参数分开</p>
<p><code>$?</code>指的是上个命令的退出状态，或函数返回值</p>
<p><code>$#</code>指的是传递给脚本或函数的参数个数</p>
<p><a href="https://www.cnblogs.com/davygeek/p/5670212.html" target="_blank" rel="noopener">Shell特殊变量：Shell  \$0, \$#, \$*, \$@, \$?, \$$和命令行参数</a></p>
<p>####常用的Shell命令，如ls、cd、dd、pwd、ps、cp、chown、chmod、mkdir、size等的具体用法。</p>
<p>ls (list)列出所有文件</p>
<p>cd (change directory)换工作目录</p>
<p>dd (disk dump)指定大小拷贝文件</p>
<p>pwd (print working directory)打印工作目录</p>
<p>ps (processes status) 显示终端下所有进程</p>
<p>cp （copy）复制</p>
<p>chown (change owner)改变文件的所有者</p>
<p>chmod (change mode )改变文件的权限模式</p>
<p>mkdir (make directory)</p>
<p>size 显示目标文件长度</p>
<h4 id="什么是管道？哪些文件参与了管道？在命令行下和通过编程如何实现管道？"><a href="#什么是管道？哪些文件参与了管道？在命令行下和通过编程如何实现管道？" class="headerlink" title="什么是管道？哪些文件参与了管道？在命令行下和通过编程如何实现管道？"></a>什么是管道？哪些文件参与了管道？在命令行下和通过编程如何实现管道？</h4><p>管道是进程间的通信的工具</p>
<p>stdin, stdout, stderr三个文件参与了管道</p>
<p>在命令行下，可以通过”|”实现管道。前一个进程产生的输入传输道后一个进程之中。</p>
<p>在linux c下，可以通过pipe去实现管道</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">无名管道的生成</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pipefd[<span class="number">2</span>]; <span class="comment">// pipefd[0]是输入fd, pipefd[1]是输出fd</span></span><br><span class="line">    pipe(pipefd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="常规文件和目录文件的差别是什么？常规文件、目录文件、软链接文件的长度如何计算？"><a href="#常规文件和目录文件的差别是什么？常规文件、目录文件、软链接文件的长度如何计算？" class="headerlink" title="常规文件和目录文件的差别是什么？常规文件、目录文件、软链接文件的长度如何计算？"></a>常规文件和目录文件的差别是什么？常规文件、目录文件、软链接文件的长度如何计算？</h4><p>目录文件也是一种特殊的文件，里面存放的是父目录节点和孩子文件。</p>
<p>常规文件只要用户拥有读权限就可以读，如果用户拥有写权限就可以写。</p>
<p>目录文件的读只需用户拥有这个目录的读权限，但是写时靠操作系统内核写的。</p>
<p>常规文件的长度根据其内容计算。</p>
<p>目录大小根据目录文件对应的inode的Block的大小。一般文件不多的情况下都是4096即4K的大小。而一般情况下都是4K的n倍，n取决于目录下文件的数量</p>
<p>软链接的文件长度就是目标文件的文件名字符长度，就比如一个指向<code>AAA</code>的软连接的文件大小是3，因为<code>AAA</code>有三个字符</p>
<h4 id="怎样移动文件？在命令行方式下和通过编程如何实现？"><a href="#怎样移动文件？在命令行方式下和通过编程如何实现？" class="headerlink" title="怎样移动文件？在命令行方式下和通过编程如何实现？"></a>怎样移动文件？在命令行方式下和通过编程如何实现？</h4><p>在命令行的方式下，可以通过mv命令来移动文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv oldFile oneDir/newFile</span><br></pre></td></tr></table></figure>
<p>在Linux C下貌似没有直接移动文件的函数，但是可以通过创建硬链接和删除原有链接的方式实现</p>
<h4 id="怎样利用gcc编译源文件？gcc的-o、-e、-static、-Wall等选项的具体含义是什么？怎样使用？"><a href="#怎样利用gcc编译源文件？gcc的-o、-e、-static、-Wall等选项的具体含义是什么？怎样使用？" class="headerlink" title="怎样利用gcc编译源文件？gcc的-o、-e、-static、-Wall等选项的具体含义是什么？怎样使用？"></a>怎样利用gcc编译源文件？gcc的-o、-e、-static、-Wall等选项的具体含义是什么？怎样使用？</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc cFile.c</span><br></pre></td></tr></table></figure>
<p>生成一个名为a.out的可执行文件</p>
<p>-o可以指定生成文件的名字</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o test cFile.c</span><br></pre></td></tr></table></figure>
<p>之后生成名为test的可执行文件</p>
<p>-E只激活预处理，并不生成文件</p>
<p>需要将其重定向到一个输出文件里面</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E cFile.c &gt; redirector.c</span><br></pre></td></tr></table></figure>
<p>-static静态编译，生成的文件不依赖动态链接库而使用静态链接库，可移植性高，缺点是生成的可执行文件非常大</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -static cFile.c</span><br></pre></td></tr></table></figure>
<p>-Wall在编译过程中会显示所有的warning信息</p>
<h4 id="什么是动态链接库？什么是静态链接库？怎样用静态链接的方式编译C程序？"><a href="#什么是动态链接库？什么是静态链接库？怎样用静态链接的方式编译C程序？" class="headerlink" title="什么是动态链接库？什么是静态链接库？怎样用静态链接的方式编译C程序？"></a>什么是动态链接库？什么是静态链接库？怎样用静态链接的方式编译C程序？</h4><p>动态链接库(dynamic link library, dll)是指可以c等编程语言在变编译时候依赖的库。在编译过程中这些库不会链接到可执行文件中，所以文件大小比较小，缺点是可移植性不强</p>
<p>静态链接库(.lib文件)是在c等编程语言在编译的时候将库链接到可执行文件中，所以文件大小比较大，但是又较好的可移植性</p>
<p>gcc默认使用动态链接地方式编译，如果想使用静态链接就需要用-static选项</p>
<h4 id="什么是文件系统？UNIX的文件系统有什么特点？有哪些具体的文件类型？"><a href="#什么是文件系统？UNIX的文件系统有什么特点？有哪些具体的文件类型？" class="headerlink" title="什么是文件系统？UNIX的文件系统有什么特点？有哪些具体的文件类型？"></a>什么是文件系统？UNIX的文件系统有什么特点？有哪些具体的文件类型？</h4><p>文件系统是操作系统在存储设备上组织文件的方法和数据结构。</p>
<p>UNIX的文件系统是依靠inode的vnode的。</p>
<p>在进程表项中都维护一个文件表，文件表中有文件状态标志、当前文件的偏移量和vnode指针。vnode指针指向了一个vnode节点，其中包含了vnode节点信息和对inode的指针。</p>
<p>inode指向了磁盘上的文件。</p>
<p>磁盘上的文件至少对应一个inode，当一个文件的inode达到0时，文件被正式删除。</p>
<p>每个目录的硬链接数至少有2个，自己与父目录。</p>
<p>具体的文件类型：</p>
<ul>
<li>常规文件</li>
<li>目录文件</li>
<li>字符特殊文件：对设备不带缓冲的访问</li>
<li>块特殊文件：对设备带缓冲的访问</li>
<li>FIFO：用于进程间的通信</li>
<li>套接字：用于进程间的网络通信</li>
<li>软链接</li>
</ul>
<h4 id="什么是文件的访问权限？使用chmod命令怎样改变访问权限？chmod-0777是什么意思？"><a href="#什么是文件的访问权限？使用chmod命令怎样改变访问权限？chmod-0777是什么意思？" class="headerlink" title="什么是文件的访问权限？使用chmod命令怎样改变访问权限？chmod 0777是什么意思？"></a>什么是文件的访问权限？使用chmod命令怎样改变访问权限？chmod 0777是什么意思？</h4><p>访问权限指的是文件是否可以被不同类型的人访问的标识符</p>
<p>chmod</p>
<p>在shell中是</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod u+x g+w filename #user现在可以执行，group现在可以写入</span><br><span class="line">chmod u=rwx g=rw o=r filename #对于filename来说，user现在read write execute都被允许，group只被允许read和write，other可以read</span><br></pre></td></tr></table></figure>
<p>chmod 0777代表着对于user/group/others来说，都可以对filename读写执行了</p>
<h4 id="什么是文件操作是的偏移量（offset）？它的数据类型是什么？操作系统中文件的最大长度取决于什么？"><a href="#什么是文件操作是的偏移量（offset）？它的数据类型是什么？操作系统中文件的最大长度取决于什么？" class="headerlink" title="什么是文件操作是的偏移量（offset）？它的数据类型是什么？操作系统中文件的最大长度取决于什么？"></a>什么是文件操作是的偏移量（offset）？它的数据类型是什么？操作系统中文件的最大长度取决于什么？</h4><p>偏移量指的是现在文件操作的指针指向的是文件的第几个字节。</p>
<p>数据类型是offset_t</p>
<p>操作系统中文件的最大长度取决于文件自身的字节数和块大小。#有点迷，不回答</p>
<h4 id="什么是管道？什么是文件重定向？dup-、dup2-函数怎样使用？"><a href="#什么是管道？什么是文件重定向？dup-、dup2-函数怎样使用？" class="headerlink" title="什么是管道？什么是文件重定向？dup()、dup2()函数怎样使用？"></a>什么是管道？什么是文件重定向？dup()、dup2()函数怎样使用？</h4><p>管道是进程间的通信的工具</p>
<p>文件重定向是指将进程的标准输出或标准输入换成文件流 </p>
<p><code>int dup(int oldd);</code></p>
<p>dup返回新文件描述符是当前可用文件描述符中的最小值</p>
<p><code>int dup2(int fd, int fd2);</code></p>
<p>dup2可以用fd2指定新描述符的值，如果fd2已经打开，则先将其关闭。</p>
<h4 id="什么是文件的静态属性和动态属性（文件描述符属性）？在文件描述符属性中，哪些是由进程维护的？哪些是由内核维护的？"><a href="#什么是文件的静态属性和动态属性（文件描述符属性）？在文件描述符属性中，哪些是由进程维护的？哪些是由内核维护的？" class="headerlink" title="什么是文件的静态属性和动态属性（文件描述符属性）？在文件描述符属性中，哪些是由进程维护的？哪些是由内核维护的？"></a>什么是文件的静态属性和动态属性（文件描述符属性）？在文件描述符属性中，哪些是由进程维护的？哪些是由内核维护的？</h4><p>静态属性：由stat()函数显示的文件属性都是静态属性。包括…. ls -l的结果都是</p>
<p>动态属性：</p>
<p>进程维护：</p>
<p>//todo: fix it up</p>
<h4 id="什么是会话（Session）、进程组？它们之间有什么关系？"><a href="#什么是会话（Session）、进程组？它们之间有什么关系？" class="headerlink" title="什么是会话（Session）、进程组？它们之间有什么关系？"></a>什么是会话（Session）、进程组？它们之间有什么关系？</h4><p>进程组是一个或多个进程的集合</p>
<p>会话是一个或多个进程组的集合。</p>
<p>关系：会话是一个或多个进程组的集合。</p>
<h4 id="父进程和子进程之间是什么关系？怎样在父子进程之间共享文件描述符？"><a href="#父进程和子进程之间是什么关系？怎样在父子进程之间共享文件描述符？" class="headerlink" title="父进程和子进程之间是什么关系？怎样在父子进程之间共享文件描述符？"></a>父进程和子进程之间是什么关系？怎样在父子进程之间共享文件描述符？</h4><p>父进程通过调用fork函数生成子进程，并且通过waitpid的方式回收子进程使其不成为僵尸进程。在子进程未通过调用exec执行新的代码的时候，父进程与子进程的所有信息完全相同，包括文件表。</p>
<p>在子进程创建之初就已经共享文件描述符（因为父进程与子进程的文件表相同。）只要在fork之前打开的文件，都可以被父子进程共享。</p>
<h4 id="在一个进程中，文件描述符的增长规律是怎样的？例如，如果已经有0、1、2、6这样几个文件描述符，那么用open-返回的下一个文件描述符是什么？"><a href="#在一个进程中，文件描述符的增长规律是怎样的？例如，如果已经有0、1、2、6这样几个文件描述符，那么用open-返回的下一个文件描述符是什么？" class="headerlink" title="在一个进程中，文件描述符的增长规律是怎样的？例如，如果已经有0、1、2、6这样几个文件描述符，那么用open()返回的下一个文件描述符是什么？"></a>在一个进程中，文件描述符的增长规律是怎样的？例如，如果已经有0、1、2、6这样几个文件描述符，那么用open()返回的下一个文件描述符是什么？</h4><p>是最小的未被使用的的非负整数。3</p>
<h4 id="什么是process-id？父进程和子进程的pid之间有什么关系？（通常子进程的pid要大于父进程的pid）"><a href="#什么是process-id？父进程和子进程的pid之间有什么关系？（通常子进程的pid要大于父进程的pid）" class="headerlink" title="什么是process id？父进程和子进程的pid之间有什么关系？（通常子进程的pid要大于父进程的pid）"></a>什么是process id？父进程和子进程的pid之间有什么关系？（通常子进程的pid要大于父进程的pid）</h4><p>process id 即进程id，是一个进程独有的编号；</p>
<p>父进程总是会比子进程先创建出来，故父亲的pid&lt;子进程pid。</p>
<h4 id="什么是C语言程序的入口函数？在C-Startup-Routine（start-S）中接受的main函数原型是什么？"><a href="#什么是C语言程序的入口函数？在C-Startup-Routine（start-S）中接受的main函数原型是什么？" class="headerlink" title="什么是C语言程序的入口函数？在C Startup Routine（start.S）中接受的main函数原型是什么？"></a>什么是C语言程序的入口函数？在C Startup Routine（start.S）中接受的main函数原型是什么？</h4><p>C语言程序的入口函数是main函数。C程序总是从main函数开始执行。</p>
<p>// todo: what the hell this is?</p>
<p>在c语言编译过程中，从<code>_start</code>开始执行。</p>
<p>而<code>_start</code>会调用<code>libc_start_main函数，libc_start_main这个函数的第一个参数就是指向一个</code>main<code>函数的指针</code></p>
<p><code>main</code>函数的签名为<code>int main(int argc, char **argv, char** environ)</code>三个参数分别代表参数的个数，参数和环境变量。</p>
<h4 id="什么是系统调用？什么是C语言库函数？它们之间有什么区别和联系？"><a href="#什么是系统调用？什么是C语言库函数？它们之间有什么区别和联系？" class="headerlink" title="什么是系统调用？什么是C语言库函数？它们之间有什么区别和联系？"></a>什么是系统调用？什么是C语言库函数？它们之间有什么区别和联系？</h4><p>系统调用：unix操作系统所提供的良好定义、数量有限、之间进入内核的入口点</p>
<p>C语言库函数：这里指的是程序员使用的通用库函数。虽然折现函数可能会调用一个或多个内核的系统调用，但是它们都不是内核的入口点</p>
<p>联系：它们都通过C函数的形式出现并且都为应用程序提供服务</p>
<p>区别：</p>
<ol>
<li>库函数是可以灵活地被替换的，但是系统调用不是</li>
<li>两者的职责和操作的层面不同。库函数常在用户层次管理上而系统调用在内核层次上</li>
</ol>
<h4 id="什么是inode？里面存放什么信息？文件的文件名存放在哪里？"><a href="#什么是inode？里面存放什么信息？文件的文件名存放在哪里？" class="headerlink" title="什么是inode？里面存放什么信息？文件的文件名存放在哪里？"></a>什么是inode？里面存放什么信息？文件的文件名存放在哪里？</h4><p>inode是索引节点，是UNIX操作系统中包含文件系统重要信息的一种数据结构。</p>
<p>里面存放了包括文件所有者，文件长度，文件在磁盘上的位置的指针等等信息。</p>
<p>文件的文件名存放在目录项中</p>
<h4 id="C程序的内存布局是怎样的？从低地址到高地址依次存放哪些段？"><a href="#C程序的内存布局是怎样的？从低地址到高地址依次存放哪些段？" class="headerlink" title="C程序的内存布局是怎样的？从低地址到高地址依次存放哪些段？"></a>C程序的内存布局是怎样的？从低地址到高地址依次存放哪些段？</h4><p>从低到高：代码段，初始化过的数据，未初始化过的数据，堆，栈，命令行参数和环境变量</p>
<p>其中程序的静态变量都放在代码段中。</p>
<p>在栈中，后入的变量居于低地址，先入的变量居于高地址</p>
<h4 id="怎样利用fork-、exec-、waitpid-来创建和控制进程？"><a href="#怎样利用fork-、exec-、waitpid-来创建和控制进程？" class="headerlink" title="怎样利用fork()、exec()、waitpid()来创建和控制进程？"></a>怎样利用fork()、exec()、waitpid()来创建和控制进程？</h4><p>父进程调用fork()，之后程序中应该有一个条件判断判断是否为子进程，如果是，则子进程调用exec，并且会将if中其他代码全部替换掉。之后，父进程执行waitpid，回收子进程，防止其变为僵尸进程</p>
<h4 id="什么是孤儿进程、什么是僵尸进程？它们有什么特点？怎样避免产生过多僵尸进程？"><a href="#什么是孤儿进程、什么是僵尸进程？它们有什么特点？怎样避免产生过多僵尸进程？" class="headerlink" title="什么是孤儿进程、什么是僵尸进程？它们有什么特点？怎样避免产生过多僵尸进程？"></a>什么是孤儿进程、什么是僵尸进程？它们有什么特点？怎样避免产生过多僵尸进程？</h4><p>孤儿进程就是指父进程早于子进程结束，从而没有父进程的子进程</p>
<p>孤儿进程会被1号进程托管，并且在结束的时候被回收</p>
<p>僵尸进程就是指由于种种原因，父进程迟迟不使用<code>wait</code>和<code>waitpid</code>回收的子进程</p>
<p>僵尸进程一直在进程表中占有一个进程表象，但并没有占用任何资源（因为进程结束的时候资源早已回收）</p>
<p>可以使用两次fork的方法避免产生过多的僵尸进程。调用两次fork然后直接杀死子进程，留下孙子进程被1号进程托管，待其结束被1号进程回收。</p>
<h4 id="什么是前台进程？什么是后台进程？一个会话有几个前台进程组和几个后台进程组？"><a href="#什么是前台进程？什么是后台进程？一个会话有几个前台进程组和几个后台进程组？" class="headerlink" title="什么是前台进程？什么是后台进程？一个会话有几个前台进程组和几个后台进程组？"></a>什么是前台进程？什么是后台进程？一个会话有几个前台进程组和几个后台进程组？</h4><p>前台进程：用户使用的有控制终端的进程 </p>
<p>后台进程：也称守护进程，是运行在后台的一种特殊进程。独立于控制终端并且周期性地执行某种任务或者等待处理某些发生的事件。常驻于内存中，防止关掉Control Terminal常驻内存消失。</p>
<p>一个会话中包含一个前台进程组，一个或多个后台进程组。 </p>
<h4 id="C程序如何退出并返回操作系统？exit-函数和-exit-Exit-函数的差别在哪里？"><a href="#C程序如何退出并返回操作系统？exit-函数和-exit-Exit-函数的差别在哪里？" class="headerlink" title="C程序如何退出并返回操作系统？exit()函数和_exit()/_Exit()函数的差别在哪里？"></a>C程序如何退出并返回操作系统？exit()函数和_exit()/_Exit()函数的差别在哪里？</h4><p>进程的终止方式有 8 种,其中 5 种为正常终止</p>
<ol>
<li>从 main 返回。   </li>
<li>调用 exit。   </li>
<li>调用_exit 或_Exit。   </li>
<li>最后一个线程从其启动例程返回。   </li>
<li>最后一个线程调用pthread_exit。   </li>
</ol>
<p>另外三种为异常终止方式,它们是   </p>
<ol>
<li>调用 abort。   </li>
<li>接到一个信号并终止。   </li>
<li>最后一个线程对取消请求做出响应。  </li>
</ol>
<p><code>void exit(int status)</code></p>
<p><code>void _Exit(int status)</code></p>
<p><code>void _exit(int status)</code></p>
<p>第一个是C语言的库函数</p>
<p>第二个是系统调用的POSIX标准的函数</p>
<p>第三个系统调用的ISO标准的函数</p>
<h4 id="exec函数族包含哪些具体的函数？其中execve是系统调用，其它都是普通函数。"><a href="#exec函数族包含哪些具体的函数？其中execve是系统调用，其它都是普通函数。" class="headerlink" title="exec函数族包含哪些具体的函数？其中execve是系统调用，其它都是普通函数。"></a>exec函数族包含哪些具体的函数？其中execve是系统调用，其它都是普通函数。</h4><table>
<thead>
<tr>
<th>函数签名</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>int execl(const char * pathname, const char * arg0, .../*, NULL*/);</code></td>
<td>根据pathname所代表的文件路径通过给定的参数执行进程。注意arg0应该是程序本身</td>
</tr>
<tr>
<td><code>int execle(const char * pathname, const char * arg0, ..., /*, NULL, char * const envp[]*/);</code></td>
<td>根据pathname所代表的文件路径通过给定的参数执行进程。最后一个参数是环境变量数组。注意arg0是程序本身</td>
</tr>
<tr>
<td><code>int execlp(const char * pathname, const char * arg0, ... /*, NULL*/);</code></td>
<td>在环境变量中根据pathname找文件并且通过给定参数执行进程。注意arg0应该是程序本身</td>
</tr>
<tr>
<td><code>int execv(const char * pathname, char * const argv[]);</code></td>
<td>根据pathname所代表的文件路径通过给定的参数的数组执行进程。注意数组第一个元素应该是程序本身</td>
</tr>
<tr>
<td><code>int execvp(const char * pathname, const char * arg0);</code></td>
<td>在环境变量中根据pathname找文件并且通过给定参数的数组执行进程。注意数组第一个元素应该是程序本身</td>
</tr>
<tr>
<td><code>int fexecve(int fd, char * const argv[], char * const envp[]);</code></td>
<td>在环境变量中根据file descriptor找文件并且通过给定参数的数组执行进程。注意数组第一个元素应该是程序本身。最后一个参数是环境变量数组</td>
</tr>
<tr>
<td><code>int execve(const char * pathname, char * const argv[], char * const envp[]);</code></td>
<td>真正的系统调用。根据pathname所代表的文件路径通过给定的参数的数组执行进程。注意数组第一个元素应该是程序本身。最后一个参数是环境变量数</td>
</tr>
</tbody>
</table>
<p>####*什么是信号？SIGINT、SIGSTOP、SIGHUP、SIGALARM、SIGQUIT等信号是如何产生的？缺省的处理动作是什么？    </p>
<p>信号是异步事件通知进程的一种方式。 </p>
<p>信号处理函数靠内核进行</p>
<p>因为这个已经脱离了用户自定义的范围，转而变成了操作系统的范围</p>
<p>信号产生的方法：</p>
<ol>
<li><p>用户通过按某些终端键可以引发终端产生信号</p>
</li>
<li><p>硬件异常产生信号</p>
</li>
<li><p>用户可以通过kill函数讲任意信号发给另一个进程或进程组。接收信号的进程和发送信号的进程的所有者必须相同。或者发送信号进程的所有者是超级用户</p>
</li>
<li><p>用户通过kill命令讲信号发送给其他进程</p>
</li>
<li><p>当检测到某种软件条件已经发生并应该将其通知有关进程时也产生信号。</p>
<p>这四个缺省的处理动作都是终止。</p>
</li>
</ol>
<h4 id="什么是硬链接和软链接（符号链接）？读取软连接的函数是什么？（readlink）"><a href="#什么是硬链接和软链接（符号链接）？读取软连接的函数是什么？（readlink）" class="headerlink" title="什么是硬链接和软链接（符号链接）？读取软连接的函数是什么？（readlink）"></a>什么是硬链接和软链接（符号链接）？读取软连接的函数是什么？（readlink）</h4><p>硬链接：通过 i 节点链接使多个目录项指向同一个文件的这种链接类型。   </p>
<p>符号链接：对一个文件的间接指针，一般用于将一个文件或整个目录结构移到文件系统中的另一个位置。</p>
<p><code>ssize_t readlink(const char * restrict pathname, char * restrict buf, size_t bufsize)</code>可以打开软连接并且读该软链接中的名字 </p>
<h4 id="函数link-和unlink-的作用是什么？什么时候文件占用的磁盘空间才会真正被释放掉？（两个条件）"><a href="#函数link-和unlink-的作用是什么？什么时候文件占用的磁盘空间才会真正被释放掉？（两个条件）" class="headerlink" title="函数link()和unlink()的作用是什么？什么时候文件占用的磁盘空间才会真正被释放掉？（两个条件）"></a>函数link()和unlink()的作用是什么？什么时候文件占用的磁盘空间才会真正被释放掉？（两个条件）</h4><p><code>int link(const char * existingpath, const char * newpath);</code>根据existingpath创造一个路径为newpath的硬链接。</p>
<p><code>int unlink(const char * pathname);</code>删除一个硬链接</p>
<p>当：</p>
<ol>
<li><p>没有硬链接指向文件</p>
</li>
<li><p>进程关闭该文件或进程终止</p>
<p>时，在磁盘空间内的文件才会被释放掉</p>
</li>
</ol>
<h4 id="什么是可重入函数？怎样判断一个函数是不是可重入函数？"><a href="#什么是可重入函数？怎样判断一个函数是不是可重入函数？" class="headerlink" title="什么是可重入函数？怎样判断一个函数是不是可重入函数？"></a>什么是可重入函数？怎样判断一个函数是不是可重入函数？</h4><p>可重入函数是在信号处理程序中保证调用安全的函数。</p>
<p>不是可重入函数的几个特点：</p>
<ol>
<li>使用静态数据结构</li>
<li>他们调用<code>malloc</code>或<code>free</code></li>
<li>它们是标准I/O函数</li>
</ol>
<h4 id="什么是带缓冲的输出和不带缓冲的输出？当父进程的输出缓冲区还未清空时，调用fork创建子进程，会出现什么情况？"><a href="#什么是带缓冲的输出和不带缓冲的输出？当父进程的输出缓冲区还未清空时，调用fork创建子进程，会出现什么情况？" class="headerlink" title="什么是带缓冲的输出和不带缓冲的输出？当父进程的输出缓冲区还未清空时，调用fork创建子进程，会出现什么情况？"></a>什么是带缓冲的输出和不带缓冲的输出？当父进程的输出缓冲区还未清空时，调用fork创建子进程，会出现什么情况？</h4><p>不带缓冲的输出是在调用时直接将内容输出到标准输出端/文件，而不是经过缓冲区。比如<code>printf</code>函数</p>
<p>带缓冲区的输出实在调用的时候将内容缓冲在缓冲区，等到程序结束了再一并写入输入端/文件，比如<code>fprintf</code>函数</p>
<p>会打印两次相同的内容</p>
<h4 id="编程的题目在这次考试中占很大的比重。一共有两道编程的题目。第一道跟文件操作相关，要求详细掌握的用法包括：能用open-read-write-close等函数来操纵文件；能利用lseek来形成文件中的“空洞”；能动态申请和释放空间等。"><a href="#编程的题目在这次考试中占很大的比重。一共有两道编程的题目。第一道跟文件操作相关，要求详细掌握的用法包括：能用open-read-write-close等函数来操纵文件；能利用lseek来形成文件中的“空洞”；能动态申请和释放空间等。" class="headerlink" title="编程的题目在这次考试中占很大的比重。一共有两道编程的题目。第一道跟文件操作相关，要求详细掌握的用法包括：能用open,read,write,close等函数来操纵文件；能利用lseek来形成文件中的“空洞”；能动态申请和释放空间等。"></a>编程的题目在这次考试中占很大的比重。一共有两道编程的题目。第一道跟文件操作相关，要求详细掌握的用法包括：能用open,read,write,close等函数来操纵文件；能利用lseek来形成文件中的“空洞”；能动态申请和释放空间等。</h4><p>注意点: <code>lseek</code>形成文件空洞之后要立即写入起码一个字节，否则空洞无效。</p>
<p>几个文件状态：</p>
<table>
<thead>
<tr>
<th>文件状态标志</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>O_RDONLY</td>
<td>只读打开</td>
</tr>
<tr>
<td>O_WRONLY</td>
<td>只写打开</td>
</tr>
<tr>
<td>O_RDWR</td>
<td>读写打开</td>
</tr>
<tr>
<td>O_EXEC</td>
<td>只执行打开</td>
</tr>
<tr>
<td>O_SEARCH</td>
<td>只搜索打开目录</td>
</tr>
<tr>
<td>O_APPEND</td>
<td>只添加新内容</td>
</tr>
<tr>
<td>O_NONBLOCK</td>
<td>非堵塞</td>
</tr>
<tr>
<td>O_SYNC</td>
<td>等待写完成（数据与属性）</td>
</tr>
<tr>
<td>O_DSYNC</td>
<td>等待写完成（仅数据）</td>
</tr>
<tr>
<td>O_RSYNC</td>
<td>同时读写</td>
</tr>
<tr>
<td>O_FSYNC</td>
<td>等待写完成</td>
</tr>
<tr>
<td>O_ASYNC</td>
<td>异步I/O</td>
</tr>
<tr>
<td>O_TRUNC</td>
<td>截断文件，重头再来</td>
</tr>
<tr>
<td>O_CREAT</td>
<td>创造</td>
</tr>
</tbody>
</table>
<p>几个签名：</p>
<p><code>int open(const char * pathname, int flags, mode_t mode);</code></p>
<p>返回文件描述符</p>
<p>例如</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> fd;  </span><br><span class="line">    fd=open(<span class="string">"abc"</span>,O_CREAT,<span class="number">0777</span>);  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fd=%d\n"</span>,fd);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ssize_t write(int fd, const void * buf, size_t count)</code></p>
<p>将存在buf中的写入fd指定的文件中，写入count个字节，返回写入的字节数。如果返回-1则出错</p>
<p><code>ssize_t read(int fd, void * buf, size_t count)</code></p>
<p>将fd指定的文件中的内容读到buf中，读count个字节，返回读出的字节数。如果返回-1则读出错</p>
<h4 id="第二道编程的题目跟进程和信号相关。要求详细掌握的用法包括：能用pause函数阻塞进程；能用signal设置信号处理函数；能向特定进程发送信号；能用rename移动文件；能遍历目录；能用S-ISREG宏辨别文件类型等等。切记对最后两道编程的大题要提前做好准备"><a href="#第二道编程的题目跟进程和信号相关。要求详细掌握的用法包括：能用pause函数阻塞进程；能用signal设置信号处理函数；能向特定进程发送信号；能用rename移动文件；能遍历目录；能用S-ISREG宏辨别文件类型等等。切记对最后两道编程的大题要提前做好准备" class="headerlink" title="第二道编程的题目跟进程和信号相关。要求详细掌握的用法包括：能用pause函数阻塞进程；能用signal设置信号处理函数；能向特定进程发送信号；能用rename移动文件；能遍历目录；能用S_ISREG宏辨别文件类型等等。切记对最后两道编程的大题要提前做好准备"></a>第二道编程的题目跟进程和信号相关。要求详细掌握的用法包括：能用pause函数阻塞进程；能用signal设置信号处理函数；能向特定进程发送信号；能用rename移动文件；能遍历目录；能用S_ISREG宏辨别文件类型等等。切记对最后两道编程的大题要提前做好准备</h4><p><code>int pause()</code> 使调用进程睡眠，直到接收到信号。<code>pause</code>返回-1，<code>errno</code>设置为EINTR</p>
<p><code>void (*signal(int signo, void (*func)(int)))(int)</code></p>
<p>第一个参数使调整的信号，第二个参数是一个函数，这个函数的参数是信号</p>
<p>打开目录通过</p>
<p><code>DIR * opendir(const char* name);</code></p>
<p>打开目录通过</p>
<p><code>struct dirent * readdir(DIR *dir);</code></p>
<p>返回一个struct dirent *类型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span>&#123;</span></span><br><span class="line">	<span class="keyword">ino_t</span> dino; <span class="comment">//inode number</span></span><br><span class="line">    <span class="keyword">off_t</span> d_off; <span class="comment">//offset to the next dirent</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> d_reclen <span class="comment">//length of this record</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> d_type; <span class="comment">//type of file</span></span><br><span class="line">    <span class="keyword">char</span> d_name[<span class="number">256</span>]; <span class="comment">//name of the file</span></span><br></pre></td></tr></table></figure>
<p>关闭文件夹</p>
<p><code>int closedir(DIR * dir)</code></p>
<p>注意：遍历目录的时候要把上一级和目录以及隐藏文件去掉，避免死循环遍历</p>
<p>用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">strncmp</span>(file-&gt;d_name, <span class="string">"."</span>, <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整体大概是</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="keyword">char</span> filename[<span class="number">256</span>][<span class="number">256</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">trave_dir</span><span class="params">(<span class="keyword">char</span>* path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DIR *d; <span class="comment">//声明一个句柄</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">file</span>;</span> <span class="comment">//readdir函数的返回值就存放在这个结构体中</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">sb</span>;</span>   </span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span>(!(d = opendir(path)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"error opendir %s!!!/n"</span>,path);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>((file = readdir(d)) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//把当前目录.，上一级目录..及隐藏文件都去掉，避免死循环遍历目录</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strncmp</span>(file-&gt;d_name, <span class="string">"."</span>, <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(stat(file-&gt;d_name, &amp;sb) &gt;= <span class="number">0</span> &amp;&amp; S_ISREG(sb.st_mode))<span class="comment">//如果是常规文件的话</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">strcpy</span>(filename[len++], file-&gt;d_name); <span class="comment">//保存遍历到的文件名</span></span><br><span class="line">        &#125;</span><br><span class="line">    closedir(d);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>rename移动文件</p>
<p><code>int rename(const char * oldpath, const char * newpath);</code></p>
<p>如果出错，返回-1</p>
<table>
<thead>
<tr>
<th>宏</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>S_ISLNK</td>
<td>是否为一个链接</td>
</tr>
<tr>
<td>S_ISREG</td>
<td>是否为一个常规文件</td>
</tr>
<tr>
<td>S_ISDIR</td>
<td>是否为一个目录</td>
</tr>
<tr>
<td>S_ISCHR</td>
<td>是否为一个字符串特殊文件</td>
</tr>
<tr>
<td>S_ISBLK</td>
<td>是否为一个块特殊文件</td>
</tr>
<tr>
<td>S_ISFIFO</td>
<td>是否为FIFO文件</td>
</tr>
<tr>
<td>S_ISSOCK</td>
<td>是否为一个socket文件</td>
</tr>
</tbody>
</table>
<p>这些都可以通过</p>
<p><code>int stat(const char * restrict pathname, struct stat * restrict buf);</code></p>
<p><code>int fstat(int fd, struct stat * buf);</code></p>
<p>所得到的stat结构体中的<code>st_mode</code>得到。他的类型是<code>mode_t</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> * <span class="title">buf</span> = <span class="title">NULL</span>;</span></span><br><span class="line">	<span class="keyword">int</span> result = fstat(<span class="number">3</span>, buf);</span><br><span class="line">    <span class="keyword">if</span>(result == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// this is success</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s \n"</span>, buf.st_mode);</span><br><span class="line">        <span class="keyword">if</span>(buf.st_mode == S_ISREG)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"yes, it is a regular file"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>##结语<br>有同校交友的吗……我的QQ号是1114599115，有没有小姐姐来加好友啊，我好寂寞啊~</p>

  </section>

</article>

<section class="read-more">
           
    
        
        
               
            <div class="read-more-item">
                <span class="read-more-item-dim">Older Post</span>
                <h2 class="post-list__post-title post-title"><a href="/2018/06/02/通过深度学习增强药药反应和药食反应的预测效果/" title="通过深度学习增强药药反应和药食反应的预测效果">通过深度学习增强药药反应和药食反应的预测效果</a></h2>
                <p class="excerpt">
                
                [TOC]
前言还是不要不务正业了，重新回到DDI的怀抱之中。（笑）
这篇是PNAS（美国科学院）的论文，还是有点分量的……虽然我觉得有点水
本篇文章主要讲的是基于深度学习的药物副作用与药物宇食物的作用的预测。
背景药与药(drug-drug interaction，DDI)，药与食物(drug-f
                &hellip;
                </p>
                <div class="post-list__meta"><time datetime="2018-06-02T09:34:48.000Z" class="post-list__meta--date date">2018-06-02</time> &#8226; <span class="post-list__meta--tags tags">于 
  <a class="tag-link" href="/tags/二十一世纪科学（滑稽）/">二十一世纪科学（滑稽）</a>, <a class="tag-link" href="/tags/深度学习/">深度学习</a>
</span><a class="btn-border-small" href="/2018/06/02/通过深度学习增强药药反应和药食反应的预测效果/">继续阅读</a></div>
                       
            </div>
        
     
   
   
  
</section>

  

            <footer class="footer">
    <span class="footer__copyright">
        &copy; 2018 kardel - 本站点采用 <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>
       
    </span>
    <span class="footer__copyright">
             - 基于 <a href="http://hexo.io">Hexo</a> 搭建，使用 <a href="https://github.com/monniya/hexo-theme-new-vno ">new-vno</a> 主题，由<a href="https://monniya.com ">@Monniya</a> 修改自 <a href="https://github.com/lenbo-ma/hexo-theme-vno" target="_blank">Vno</a>, 原创出自<a href="http://github.com/onevcat/vno" target="_blank">onevcat</a>
         </span>
       
    
    
</footer>


        </div>
    </div>

     
<script>
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	ga('create', 'UA-78918255-1', 'auto');
	ga('send', 'pageview');
</script>

    
    <script>
        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?9cdad07c755fa23f6aced510c6760e87";
            var s = document.getElementsByTagName("script")[0]; 
            s.parentNode.insertBefore(hm, s);
        })();
    </script>



    <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
    
</body>
</html>
