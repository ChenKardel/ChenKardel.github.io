<!DOCTYPE html>
<html lang="z">
<head>
    <meta charset="utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    
    <title>数据库复习 | Kardel的希尔伯特空间</title>
    <meta name="renderer" content="webkit">
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <meta name="description" content="浅度辍学集大成者
the man who masters shallow dropout">

    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="数据库复习 | Kardel的希尔伯特空间">
    <meta name="twitter:description" content="浅度辍学集大成者
the man who masters shallow dropout">

    <meta property="og:type" content="article">
    <meta property="og:title" content="数据库复习 | Kardel的希尔伯特空间">
    <meta property="og:description" content="浅度辍学集大成者
the man who masters shallow dropout">

    
    <meta name="author" content="kardel">
    
    <link rel="stylesheet" href="/css/vno.css">
    <link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css">

    
    <link rel="icon" href="/images/avatar-icon.png">
    

    <meta name="generator" content="hexo"/>
    
    <link rel="alternate" type="application/rss+xml" title="Kardel的希尔伯特空间" href="/atom.xml">
    

    <link rel="canonical" href="http://ChenKardel.github.io/2018/06/18/数据库复习/"/>

                 
</head>

<body class="home-template no-js">
    <script src="//cdn.bootcss.com/jquery/2.1.4/jquery.min.js"></script>
    <script src="/js/main.js"></script>
    <span class="mobile btn-mobile-menu">
        <i class="fa fa-list btn-mobile-menu__icon"></i>
        <i class="fa fa-angle-up btn-mobile-close__icon hidden"></i>
    </span>

    
<header class="panel-cover panel-cover--collapsed" style="background-image: url(/images/background-cover.jpg)">
  <div class="panel-main">
    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        <a href="/" title="前往 Kardel的希尔伯特空间 的主页"><img src="/images/avatar.jpg" width="80" alt="Kardel的希尔伯特空间 logo" class="panel-cover__logo logo" /></a>
        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage for Kardel的希尔伯特空间">Kardel的希尔伯特空间</a></h1>
        
        <hr class="panel-cover__divider" />
        <p class="panel-cover__description">浅度辍学集大成者
the man who masters shallow dropout
</p>
        <hr class="panel-cover__divider panel-cover__divider--secondary" />

        <div class="navigation-wrapper">
          <div>
          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">
              <li class="navigation__item"><a href="/#blog" title="Visit the blog" class="blog-button">Blog</a></li>
            
              <li class="navigation__item"><a href="/aboutme">关于我</a></li>
            
            </ul>
          </nav>
          </div>
          <div>
          <nav class="cover-navigation navigation--social">
  <ul class="navigation">

  <!-- Weibo-->
  

  <!-- Github -->
  
  <li class="navigation__item">
    <a href="https://github.com/ChenKardel" title="GitHub" target="_blank">
      <i class='social fa fa-github'></i>
      <span class="label">Github</span>
    </a>
  </li>


<!-- Stack Overflow -->
        

  <!-- Google Plus -->
  

<!-- Facebook -->

  
<!-- Twitter -->

  

  <li class="navigation__item">
    <a href="/atom.xml" title="RSS" target="_blank">
      <i class='social fa fa-rss'></i>
      <span class="label">RSS</span>
    </a>
  </li>



  </ul>
</nav>

          </div>
        </div>

      </div>

    </div>

    <div class="panel-cover--overlay cover-purple"></div>
  </div> 
</header>

    <div class="content-wrapper">
        <div class="content-wrapper__inner">
            <article class="post-container post-container--single">

  <header class="post-header">
    <div class="post-meta">
      <time datetime="2018-06-18T08:45:20.000Z" class="post-list__meta--date date">2018-06-18</time> &#8226; <span class="post-meta__tags tags">于 
  <a class="tag-link" href="/tags/数据库/">数据库</a>, <a class="tag-link" href="/tags/课程复习/">课程复习</a>
 </span>
      <span class="page-pv">
       Read <span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span>
      </span> 
   
    </div>
    <h1 class="post-title">数据库复习</h1>
  </header>

  <section class="post">
    <h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>注：定义性质的我都用<em>斜体</em> 标注</p>
<h3 id="数据库系统的特点和概念"><a href="#数据库系统的特点和概念" class="headerlink" title="数据库系统的特点和概念"></a>数据库系统的特点和概念</h3><h4 id="三层模式"><a href="#三层模式" class="headerlink" title="三层模式"></a>三层模式</h4><p>三层模式是指ANSI-SPARC体系结构</p>
<p><em>三层体系结构指的是外部层、概念层和内部层</em> </p>
<p>外部层提供视图，提供用户观察数据的视图</p>
<p>概念层提供内、外部层的映射和必要的独立性</p>
<p>内部层提供DBMS和操作系统观察和存储数据的结构。</p>
<h5 id="三层模式的优点："><a href="#三层模式的优点：" class="headerlink" title="三层模式的优点："></a>三层模式的优点：</h5><ol>
<li>每个用户都可以操作自己的数据视图而不影响其他用户</li>
<li>将数据库物理存储的细节隔离出来</li>
<li>DBA能够在不影响用户视图的情况下修改数据库存储结构</li>
<li>数据库的内部结构不受存储的物理变化的影响</li>
</ol>
<h5 id="外部层"><a href="#外部层" class="headerlink" title="外部层"></a>外部层</h5><p><em>外部层是数据库的用户视图，这一层描述了每一个用户相关的数据库部分</em> </p>
<p>外部层由数据库中的若干个不同视图组成。每个用户都有自己的视图，该视图用其最熟悉的方式表示现实世界</p>
<h5 id="概念层"><a href="#概念层" class="headerlink" title="概念层"></a>概念层</h5><p><em>概念层是数据库的整体视图。这一层描述了哪些数据被存储在数据库中，以及这些数据之间的联系</em></p>
<p>比如：</p>
<ul>
<li>所有实体、实体的属性和实体间的联系‘</li>
<li>数据的约束</li>
<li>数据的语义信息</li>
<li>安全性和完整性信息</li>
</ul>
<p>概念层支持每一个外部视图，凡是用户可以访问的数据必定包含在概念层或者由概念层数据可导出。</p>
<h5 id="内部层"><a href="#内部层" class="headerlink" title="内部层"></a>内部层</h5><p><em>内部层是数据库在计算机上的物理表示。这一层描述数据是如何存储在数据库中。</em></p>
<p>内部层包括为了得到数据库运行时的最佳性能而采用的物理实现方法</p>
<p>内部层与如下工作相关：</p>
<ul>
<li>数据和索引的存储空间分配</li>
<li>用于存储的记录描述（数据项的存储大小）</li>
<li>记录放置</li>
<li>数据压缩和数据加密技术</li>
</ul>
<p>内部层之下是物理层，物理层可能在DBMS的指导下受操作系统的控制。</p>
<h4 id="DB-DBMS-DBS"><a href="#DB-DBMS-DBS" class="headerlink" title="DB/DBMS/DBS"></a>DB/DBMS/DBS</h4><h5 id="DB"><a href="#DB" class="headerlink" title="DB"></a>DB</h5><p><em>为满足某个组织机构的信息要求而设计的一个逻辑相关数据及其描述的共享集</em></p>
<p>逻辑相关数据：包含实体，属性，组织机构信息的关系</p>
<p>系统目录（元数据）：提供数据的描述去使数据与程序独立</p>
<h5 id="DBMS"><a href="#DBMS" class="headerlink" title="DBMS"></a>DBMS</h5><p><em>一个支持用户对数据库进行定义、创建、维护及控制访问的软件系统</em></p>
<p>提供以下功能：</p>
<ol>
<li>数据定义语言（DDL）</li>
<li>数据控制语言（DML）</li>
<li>数据库的受控访问</li>
</ol>
<h5 id="DBS"><a href="#DBS" class="headerlink" title="DBS"></a>DBS</h5><p>数据库系统由</p>
<ol>
<li>DB：一个特定于应用程序的数据库</li>
<li>DBMS：一个可以使用户定义，创造，维护，控制数据库访问权限的软件系统</li>
<li>AP：控制数据库的应用程序</li>
</ol>
<h3 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h3><h4 id="对象关系模型"><a href="#对象关系模型" class="headerlink" title="对象关系模型"></a>对象关系模型</h4><p><em>一个描述数据、数据间的关系，约束的集成集合</em></p>
<h4 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h4><p>关系：关系是由行和列组成的表</p>
<p>属性：属性是关系中命名的列</p>
<p>域：域是一个或多个属性的取值集合</p>
<p>元组：关系中的每一行称为元组</p>
<p>维数：关系的维数是指关系所包含属性的个数（不严谨的说就是列数）</p>
<p>基数：关系的基数是指它所包含的元组的个数</p>
<p>（不严谨的说就是行数）</p>
<p>关系数据库：关系数据库是具有不同关系名的规范化关系的集合</p>
<p>关系模式：用一组属性和域名对定义的具名的关系，比如$$(A_1:d_1, A_2:d_2,…, A_n:d_n)，其中d1\in D_1, d_2\in D_2, …, d_n\in D_n$$</p>
<p>$A_i$是属性，$d_i$是值，$D_i$是域</p>
<h4 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h4><h5 id="超关键字"><a href="#超关键字" class="headerlink" title="超关键字"></a>超关键字</h5><p><em>一个属性或属性集合，它能唯一地表示出关系中每个元组</em></p>
<h5 id="候选关键字"><a href="#候选关键字" class="headerlink" title="候选关键字"></a>候选关键字</h5><p><em>本身就是超关键字但其任何子集都不再是超关键字</em></p>
<h5 id="主关键字"><a href="#主关键字" class="headerlink" title="主关键字"></a>主关键字</h5><p><em>被选用于唯一表示关系中各元组的候选关键字</em></p>
<p>实际上就相当于NOT NULL + UNIQUE</p>
<h5 id="可替换关键字"><a href="#可替换关键字" class="headerlink" title="可替换关键字"></a>可替换关键字</h5><p><em>没有被选于唯一标识关系中各元组的候选关键字</em></p>
<h5 id="外部关键字"><a href="#外部关键字" class="headerlink" title="外部关键字"></a>外部关键字</h5><p><em>当一个关系中的某个属性或属性集合域另一个关系的候选关键字匹配时，就称这个属性或属性集合为外部关键字</em></p>
<h4 id="完整性约束"><a href="#完整性约束" class="headerlink" title="完整性约束"></a>完整性约束</h4><h5 id="实体完整性"><a href="#实体完整性" class="headerlink" title="实体完整性"></a>实体完整性</h5><p><em>在基本关系中，主关键字属性不能为空</em> </p>
<h5 id="引用完整性"><a href="#引用完整性" class="headerlink" title="引用完整性"></a>引用完整性</h5><p><em>如果在关系中存在某个外部关键字，则它的值与主关系中某个元组的<strong>候选关键字</strong>取值相等，或者全为空</em></p>
<p>注意一定是候选关键字而不是一般属性</p>
<h4 id="运算操作"><a href="#运算操作" class="headerlink" title="运算操作"></a>运算操作</h4><p>八运算操作，其中五个基本运算操作</p>
<ol>
<li>集合并</li>
<li>集合差</li>
<li>笛卡尔集</li>
<li>选择</li>
<li>投影</li>
</ol>
<p>其余三个</p>
<ol start="6">
<li>连接</li>
<li>集合交</li>
<li>除<br>注意一下他们的符号</li>
</ol>
<h5 id="选择：-sigma"><a href="#选择：-sigma" class="headerlink" title="选择：$\sigma$"></a>选择：$\sigma$</h5><p>选择工资多余10000的员工：$\sigma_{salary&gt;1000}(Staff)$</p>
<h5 id="投影：-Pi"><a href="#投影：-Pi" class="headerlink" title="投影：$\Pi$"></a>投影：$\Pi$</h5><p>选出员工的staffNo，fName，lName，salary: </p>
<p>$\Pi_{staffNo, fName, lName, salary}(Staff)$</p>
<h5 id="并：-cup"><a href="#并：-cup" class="headerlink" title="并：$\cup$"></a>并：$\cup$</h5><p>$\Pi_{city}(Branch) \cup \Pi_{city}（PropertyForRent）$</p>
<h5 id="差："><a href="#差：" class="headerlink" title="差：$-$"></a>差：$-$</h5><p>$\Pi_{city}(Branch) - \Pi_{city}（PropertyForRent）$</p>
<h5 id="交：-cap"><a href="#交：-cap" class="headerlink" title="交：$\cap$"></a>交：$\cap$</h5><p>$\Pi_{city}(Branch) \cap \Pi_{city}（PropertyForRent）$</p>
<h5 id="笛卡尔集：-times"><a href="#笛卡尔集：-times" class="headerlink" title="笛卡尔集：$\times$"></a>笛卡尔集：$\times$</h5><p>$\Pi_{clientNo, fName, lName}(Client) \times \Pi_{clientNo, propertyNo, comment}（Viewing）$</p>
<p>注意两点</p>
<ol>
<li><p>如果两个表中有相同的属性，则应该用表名唯一表示</p>
<p>用书上的例子</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>client.clientNo</th>
<th>fName</th>
<th>lName</th>
<th>Viewing.clientNo</th>
<th>propertyNo</th>
<th>comment</th>
</tr>
</thead>
<tbody>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
</tbody>
</table>
<p>   其中Client表和View表都有clientNo这个属性（具体什么意思不用管了）</p>
<p>   但是为了唯一标识，要把表名列出来</p>
<ol start="2">
<li><p>这个笛卡尔集使任意交叉，没有经过筛选，要筛选需要再用次选择</p>
<p>$\sigma_{Client.clientNo = Viewing.clientNo}(\Pi_{clientNo, fName, lName}(Client) \times \Pi_{clientNo, propertyNo, comment}（Viewing)$</p>
</li>
</ol>
<h5 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h5><p>连接有很多种</p>
<ol>
<li><p>$\theta$连接</p>
<p>$\theta$连接时最简单的连接</p>
<p>$R\Join_{F}S = \sigma_{F}(R \times S)$</p>
<p>带谓语的连接</p>
</li>
<li><p>自然连接</p>
<p>自然连接是在公共属性上连接，</p>
<p>在上面的例子上可以是</p>
<p>$$\Pi_{client.clientNo, fName, lName, propertyNo, comment}(\sigma_{Client.clientNo = Viewing.clientNo}(\Pi_{clientNo, fName, lName}(Client) \times \Pi_{clientNo, propertyNo, comment}（Viewing))$$</p>
</li>
<li><p>外连接</p>
<p>外连接是两张表，展示一张表所有内容，如果另一张表没有对应内容，则填null。</p>
<p>左外连接：$\rtimes$ </p>
<p>右外连接：$\ltimes$</p>
<p>开口指向展示所有内容的一边    </p>
</li>
<li><p>半连接算了吧</p>
</li>
</ol>
<h5 id="除法运算"><a href="#除法运算" class="headerlink" title="除法运算"></a>除法运算</h5><p>除法运算问题很大</p>
<p>我觉得除法运算和分组有点像</p>
<p>具体可以看</p>
<p><a href="https://blog.csdn.net/t_1007/article/details/53036082" target="_blank" rel="noopener">关系代数中的除法运算</a></p>
<p>例如$R\div S$</p>
<p>R(X, Y)，S(Y, F)</p>
<ol>
<li>找到R,S两个集合公共属性Y</li>
<li>对着除的集合（右边的）S找它的Y，对每一个Y中的元素找被除的集合（左边的）R的X</li>
<li>如果S对给定的Y的X都是一样的，加入结果集，否则不加入</li>
<li>获取结果集</li>
</ol>
<p>PS：说不清楚啊……</p>
<p>除此之外，还可以提一下分组运算，但不如后面的SQL种讲</p>
<h3 id="SQL语言"><a href="#SQL语言" class="headerlink" title="SQL语言"></a>SQL语言</h3><p>Structured Query Language</p>
<p>SQL是DDL、DML、DQL、DCL的集成（扯什么犊子，都一箩筐）</p>
<p>SQL 不区分大小写</p>
<h4 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h4><p>数据定义语言（Data Definition Language，DDL）用于定义数据库结构和数据的访问控制</p>
<p>几个命令</p>
<ul>
<li>CREATE</li>
<li>ALTER</li>
<li>DROP</li>
<li>TRUNCATE</li>
</ul>
<h4 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h4><p>数据操作语言（Data Manipulation Language，DML）用于检索和更新数据</p>
<p>几个命令</p>
<ul>
<li>SELECT</li>
<li>DELETE</li>
<li>UPDATE</li>
<li>INSERT</li>
<li>CALL(调用PLSQL那货)</li>
<li>LOCK  TABLE</li>
</ul>
<h4 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a>DCL</h4><p>数据控制语言（Data Control Language，DCL），用来授予或回收访问数据库的某种特权，并控制数据库操纵事务发生的时间及效果，对数据库实行监视等</p>
<ul>
<li>COMMIT</li>
<li>SAVEPOINT</li>
<li>ROLLBACK</li>
<li>SET TRASACTION</li>
<li>GRANT</li>
<li>REVOKE</li>
</ul>
<p>处理事务用</p>
<p><a href="https://www.2cto.com/database/201610/555167.html" target="_blank" rel="noopener">DDL、DML和DCL的区别与理解</a> </p>
<p>不具体讲，注意几个小点</p>
<ol>
<li><p>SELECT DISTINCT * 语序不要搞反</p>
</li>
<li><p>LIKE的%是0个或多个，_是一个</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LIKE 'Hel__ %d'</span><br></pre></td></tr></table></figure>
<p>当然我隐约记得Sql lite支持^和$，</p>
<p>也可以使用NOT LIKE表示不遵循表达式数据项</p>
</li>
<li><p>在where中，如果对另一张表的查询结果只有一个，可以用=的，如果有多个，用<code>IN</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> STUDENT <span class="keyword">WHERE</span> STUDENTID = (<span class="keyword">SELECT</span> STUDENTID <span class="keyword">FROM</span> TEACHER)</span><br><span class="line"><span class="comment">-- 确保后面的查询只有一个结果（假设是一对一老师教学（滑稽））</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> TEACHER <span class="keyword">WHERE</span> TEACHERID <span class="keyword">IN</span> (<span class="keyword">SELECT</span> TEACHERID <span class="keyword">FROM</span> STUDENT)</span><br><span class="line"><span class="comment">-- 当后面查询结果有多个的时候</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>GROUP</p>
<p>GROUP BY的意思是将GROUP BY后面的属性相同的列并起来，并且呈现</p>
<p>SELECT中只有GROUP BY后面的属性可以被SELECT，其他都得被聚合函数聚合</p>
<p>GROUP中的约束用HAVING，HAVING中操作的属性在GROUP BY<strong>可以</strong>呈现的属性集合中</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> branchNo, <span class="keyword">COUNT</span>(staffNo) <span class="keyword">AS</span> myCount, <span class="keyword">SUM</span>(salary) <span class="keyword">AS</span> mySum</span><br><span class="line"><span class="keyword">FROM</span> Staff</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> branchNo</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(staffNo) &gt; <span class="number">1</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> branchNo;</span><br></pre></td></tr></table></figure>
</li>
<li><p>老生常谈的问题——效率</p>
<p>一张大表比外键连接的效率是好的，虽然大表可能会产生占内存问题，而且很多一个元组中有过多的属性也会产生低效率，但是这个可以被索引解决。</p>
<p>但是我自己实践的过程中肯定是喜欢外键的，最大的原因之一是很多框架对外键的支持比较好，可以把外键当成List查询。听说有些公司喜欢不做外键（为了规避外键约束），但是我也不懂。</p>
</li>
<li><p>索引</p>
<p>索引是一种结构，它提供了基于一个或多个列值快速访问表中元组的方法</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">UNIQUE</span>] <span class="keyword">INDEX</span> indexName <span class="keyword">ON</span></span><br><span class="line">Tablename(columnName[<span class="keyword">ASC</span>|<span class="keyword">DESC</span>][,...])</span><br></pre></td></tr></table></figure>
<p>索引只能基于表<strong>而非视图</strong>建立</p>
</li>
<li><p>自主访问控制</p>
<p>两种授权机制</p>
<ul>
<li>自主访问机制：每个用户被授予对特定的数据库对象的适当的访问权利。</li>
<li>强制访问机制：每个数据库对象被赋予特定分级，主体被赋予特定的许可证级别。主体需要必要的许可证级别来读写数据库对象。</li>
</ul>
<p>控制访问用<code>GRANT</code>和<code>REVOKE</code>操作。</p>
<p>可授权的操作：</p>
<ul>
<li>SELECT</li>
<li>INSERT</li>
<li>UPDATE</li>
<li>DELETE</li>
<li>REFERENCES可以允许在约束中引用这些列</li>
<li>USAGE（使用域/序列/字符集和转变规则（暂时跳过））</li>
</ul>
<p>授权</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GRANT &#123;PrivilegeList|ALL PRIVIEGES&#125;</span><br><span class="line">ON ObjectName</span><br><span class="line">TO &#123;AuthorizationIdList|PUBLIC&#125;</span><br><span class="line">[WITH GRANT OPTION]</span><br></pre></td></tr></table></figure>
<p>注意对于Privilege，SELECT, DELETE USAGE后面不用接列，INSERT，UPDATE和REFERENCE后面接列</p>
<p>WITH GRANT OPTION允许AuthorizationIdList给别人授权</p>
<p>撤销权限语法相近</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> [<span class="keyword">GRANT</span> <span class="keyword">OPTION</span> <span class="keyword">FOR</span>]&#123;PrivilegeList|ALL <span class="keyword">PRIVILEGES</span>&#125; <span class="keyword">ON</span> ObjectName</span><br><span class="line"><span class="keyword">FROM</span> &#123;AuthorizationIdList|<span class="keyword">PUBLIC</span>&#125; [RESTRICT|<span class="keyword">CASCADE</span>]</span><br></pre></td></tr></table></figure>
<p>GRANT OPTION FOR允许GRANT语句中的WITH GRANT OPTION传递的权限被撤销</p>
<p>RESTRICT 和CASCADE是针对REVOKE说的，在RESTRICT下，如果REVOKE导致一个对象（比如视图）被抛弃，则不能执行。</p>
<p>但是在CASCADE下所有因REVOKE而被抛弃的对象都将被依次抛弃</p>
</li>
</ol>
<h3 id="PLSQL"><a href="#PLSQL" class="headerlink" title="PLSQL"></a>PLSQL</h3><p>淦，内容怎么这么多，我都快没耐心了</p>
<p>PLSQL就是你懂的~Programming Language SQL</p>
<p>声明</p>
<figure class="highlight plain"><figcaption><span>VaRCHAR2(5);```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">想要与另一个列或变量类型相同，可以用`%TYPE`</span><br><span class="line"></span><br><span class="line">`vStaffNo Staff.staffNo%TYPE`</span><br><span class="line"></span><br><span class="line">赋值`:=`</span><br><span class="line"></span><br><span class="line">控制语句</span><br><span class="line"></span><br><span class="line">```plsql</span><br><span class="line">IF (condition) THEN</span><br><span class="line">...</span><br><span class="line">[ELSIF (condition) THEN ...]</span><br><span class="line">[ELSE ...]</span><br><span class="line">END IF;</span><br></pre></td></tr></table></figure>
<p>以及</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CASE(x)</span><br><span class="line">WHEN() THEN</span><br><span class="line">...</span><br><span class="line">END CASE;</span><br></pre></td></tr></table></figure>
<p>循环</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">label:</span><br><span class="line">LOOP</span><br><span class="line">...</span><br><span class="line">EXIT label [WHEN(condition)];</span><br><span class="line">END LOOP label;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">label:</span><br><span class="line">FOR item IN 下限..上限 LOOP</span><br><span class="line">...</span><br><span class="line">END LOOP label;</span><br></pre></td></tr></table></figure>
<h5 id="PLSQL游标"><a href="#PLSQL游标" class="headerlink" title="PLSQL游标"></a>PLSQL游标</h5><p>游标：游标就像一个指向查询结果中特定行的指针，游标可以前进一格，以便访问下一行</p>
<p>语法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">DECLARE</span><br><span class="line">	-- 在变量申明阶段就定义游标</span><br><span class="line">	vName VARCHAR2(100)</span><br><span class="line">	vAge NUMBER(10)</span><br><span class="line">	-- 声明一个游标</span><br><span class="line">	CURSOR studentCursor IS</span><br><span class="line">		SELECT name, age FROM STUDENT</span><br><span class="line">		WHERE STUDENT.SEX = &quot;m&quot;</span><br><span class="line">BEGIN</span><br><span class="line">	--打开游标</span><br><span class="line">	OPEN studentCursor;</span><br><span class="line">	LOOP </span><br><span class="line">	-- 用FECTCH将cursor中读出的元组中的值塞到声明的变量中</span><br><span class="line">		FETCH studentCursor INTO vName, vAge;</span><br><span class="line">	-- 当没有的时候用 %NOTFOUND 通知</span><br><span class="line">	EXIT WHEN studentCursor%NOTFOUND;</span><br><span class="line">	-- 用 || 连接字符串</span><br><span class="line">	dbms_output.put_line(&apos;stuednt.name = &apos; || vName);</span><br><span class="line">	dmbs_output.put_line(&apos;student.age = &apos; || vAge);</span><br><span class="line">	END LOOP;</span><br><span class="line">	CLOSE studentCursor;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure>
<p>这和JDBC中的<code>ResultSet</code>一个逻辑</p>
<h5 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h5><p>就整一函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">create or replace procedure &#123;procedureName&#125;</span><br><span class="line">    (parameterName [in|out|in out] parameterType,</span><br><span class="line">     ...)</span><br><span class="line"> as   </span><br><span class="line"> 	-- 这里相当于忽略了DECLARE	</span><br><span class="line">	variableName variableType;</span><br><span class="line"> begin  </span><br><span class="line"> 	-- 具体内容</span><br><span class="line">	-- blabla </span><br><span class="line">	...</span><br><span class="line">end;</span><br></pre></td></tr></table></figure>
<p>注意参数的IN /OUT /IN OUT</p>
<p>IN只能作为输入值</p>
<p>OUT只能作为输出值</p>
<p>IN OUT既可作为输入值，也可作为输出值</p>
<h5 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h5><p>触发器如果是习惯作UI的同学应该都是秒懂的</p>
<p>就是根据事件做出反应</p>
<p>语法为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TRIGGER triggerName</span><br><span class="line">	&#123;BEFORE|AFTER|INSTEAD OF&#125;</span><br><span class="line">	INSERT|DELETE|UPDATE OF COLUMNNAME1, COLUMNNAME2, ....</span><br><span class="line">	ON TABLENAME</span><br><span class="line">	REFERENCING OLD|NEW AS ROWNAME</span><br><span class="line">	BEGIN</span><br><span class="line">	....</span><br><span class="line">	END;</span><br></pre></td></tr></table></figure>
<p>之前实践的时候想到一点：我觉得hibernate对PLSQL原生触发器的支持非常差。相对的，hibernate支持Java程序编写的事件监听器<code>EventListener</code>和拦截器<code>Interceptor</code>所以使用hibernate的时候就可以放弃触发器了</p>
<h3 id="DB设计"><a href="#DB设计" class="headerlink" title="DB设计"></a>DB设计</h3><h4 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h4><p><em>视图是为了得到另一个关系而对基关系作一次或多个关系操作的动态结果</em></p>
<p>视图是</p>
<ol>
<li>一个虚拟关系，并不存在于数据库中，需要特定用户的要求临时生成</li>
<li>一个或多个关系操作的动态结果</li>
</ol>
<p>CREATE代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE VIEW VIEWNAME [(COLUMNNAME1, ...)]</span><br><span class="line">AS </span><br><span class="line">... </span><br><span class="line">-- select 语句，比如</span><br><span class="line">-- select * from aTable</span><br><span class="line">[WITH[CASCADED|LOCAL] CHECK OPTION]</span><br></pre></td></tr></table></figure>
<p>视图就像个筛子，只会筛选出符合条件的元组（<code>WHERE</code>中的条件）</p>
<p>迁移行：如果对视图进行插入和更新时有新行满足或不满足<code>WHERE</code>条件则这些新行就会出现或消失在视图中</p>
<p>通过<code>WITH CHECK OPTION</code>限制迁移行。</p>
<p>有两个选项<code>CASCADED</code>和<code>LOCAL</code>，默认情况下都是<code>CASCADED</code></p>
<p><code>CASCADED</code>使任何对这个视图或其他的从这个视图创建的视图的插入与修改操作不得使行消失</p>
<p><code>LOCAL</code>使任何对这个视图或其他的从这个视图中创建的视图的插入和修改操作不得使行消失，除非在从这个视图中父的所有视图这一行也消失了（不满足所有派生视图(derived view)的条件）</p>
<h5 id="视图分解"><a href="#视图分解" class="headerlink" title="视图分解"></a>视图分解</h5><p>视图分解时在查询视图的过程中，将用作视图定义的查询与在视图上的查询合并</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> view1 <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> A0, A1 <span class="keyword">FROM</span> A</span><br><span class="line"><span class="keyword">WHERE</span> A0 = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> A0 <span class="keyword">FROM</span> A <span class="keyword">WHERE</span> A1 = <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>可以转化为</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> A0 <span class="keyword">FROM</span> A <span class="keyword">WHERE</span> A0 = <span class="number">1</span> <span class="keyword">AND</span> A1 = <span class="number">3</span></span><br></pre></td></tr></table></figure>
<h5 id="视图的限制"><a href="#视图的限制" class="headerlink" title="视图的限制"></a>视图的限制</h5><ol>
<li>如果视图中某个列时由聚合函数产生的，那它只能被SELECT和ORDER BY</li>
<li>分组视图不能和基表或视图连接</li>
</ol>
<h5 id="视图可更新的限制"><a href="#视图可更新的限制" class="headerlink" title="视图可更新的限制"></a>视图可更新的限制</h5><ol>
<li>没有指定DISTINCT</li>
<li>定义的SELECT列表中的元素都是列名而不是聚合函数和常量和表达式。</li>
<li>FROM只指定一个表</li>
<li>WHERE子句不能引用FROM子句中的表的嵌套SELECT操作</li>
<li>不能有GROUP BY</li>
</ol>
<p>不能违反基表约束</p>
<h4 id="ER模型"><a href="#ER模型" class="headerlink" title="ER模型"></a>ER模型</h4><h5 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h5><p><em>能够独立存在的一组具有相同属性的对象</em></p>
<h5 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h5><p><em>实体类型键的一组有意义的关联</em></p>
<h5 id="度"><a href="#度" class="headerlink" title="度"></a>度</h5><p><em>参与联系的实体类型的个数</em></p>
<p>两个实体之间的关系就是二元关系，度为二</p>
<p>三个实体之间的关系就是三元关系，度为三</p>
<p>度为二以上的关系都被称作复杂关系</p>
<p>实际上多元关系都可以转化为二元关系</p>
<hr>
<p>属性，属性域，简单属性，复杂属性，单值属性，组合属性，单值属性，多值属性</p>
<p>以上我都懒得讲</p>
<h5 id="导出属性"><a href="#导出属性" class="headerlink" title="导出属性"></a>导出属性</h5><p><em>导出属性是从相关的一个或一组属性的值导出来的属性</em></p>
<p>注意导出属性算属性不算函数（别问我为什么说这个）</p>
<h5 id="候选关键字-1"><a href="#候选关键字-1" class="headerlink" title="候选关键字"></a>候选关键字</h5><h5 id="主关键字-1"><a href="#主关键字-1" class="headerlink" title="主关键字"></a>主关键字</h5><h5 id="合成关键字"><a href="#合成关键字" class="headerlink" title="合成关键字"></a>合成关键字</h5><p>包括两个或两个以上属性的候选关键字</p>
<p><img src="/2018/06/18/数据库复习/ER.png" alt="图形标识"></p>
<h5 id="陷阱"><a href="#陷阱" class="headerlink" title="陷阱"></a>陷阱</h5><ul>
<li>扇形陷阱：当一个实体连接了两个一对多实体时，会产生扇形陷阱</li>
</ul>
<p><img src="/2018/06/18/数据库复习/扇形陷阱.png" alt="扇形陷阱"></p>
<p>解决方案就是重新理解需求并且重构，做出1：M：N的结构出来</p>
<ul>
<li><p>断层陷阱：当一个实体与一些实体时1…M:1…N，但是与另一些实体产生了0…1: 0…*（有点说不清楚），几句产生了断层陷阱</p>
<p><img src="/2018/06/18/数据库复习/断层陷阱.png" alt="断层陷阱"></p>
<p>解决方案是跳过中间的断层直接作连接</p>
</li>
</ul>
<p>（陷阱有点讲不清楚）</p>
<p>增强ER模型就是在其基础上添加了OOP的继承和多态</p>
<h5 id="泛化的约束"><a href="#泛化的约束" class="headerlink" title="泛化的约束"></a>泛化的约束</h5><p>泛化有两种约束：参与约束和不相交约束</p>
<p>参与约束：<em>限制每个超类的成员是否一定是某个子类的成员</em>，是则Mandatory，不一定则Optional</p>
<p>不相交约束：<em>说明了超类的某一个成员是仅为一个还是同时为多个子类的成员</em>，仅为一个则为Or，可为多个则为And</p>
<p>这个可理解为支持多继承与否</p>
<p>假设：中国人，程序员，大学生都继承于人，但是一个人可以既是中国人又是程序员有时大学生，所以这个关系是And。</p>
<p>但是对于都继承于人的中国人美国人日本人来说，这个关系是<strong>互斥</strong>的(别和我说JOJO，谢谢)，所以这个关系是Or。</p>
<h4 id="规范化"><a href="#规范化" class="headerlink" title="规范化"></a>规范化</h4><p><em>生成一组既具有所期望的特性又能瞒住企业数据需求的关系的技术</em></p>
<p>性质：</p>
<ol>
<li>属性的个数最少</li>
<li>具有紧密逻辑联系的属性均在同一个关系中</li>
<li>最少的冗余，即每个属性只出现一次</li>
</ol>
<p>优点：</p>
<ol>
<li>易于用户访问</li>
<li>数据易于维护</li>
<li>计算机存储空间小</li>
</ol>
<p>缺点：</p>
<ol>
<li>性能相对降低</li>
</ol>
<h5 id="非规范化的数据库的异常"><a href="#非规范化的数据库的异常" class="headerlink" title="非规范化的数据库的异常"></a>非规范化的数据库的异常</h5><p>假设一张表记录了公司员工于所属公司的关系</p>
<p>它的函数依赖可以表示为</p>
<p>$staffNo, companyNo\rightarrow staffName, staffAge, staffBirthDay, companyName, companyAge$</p>
<p>其为部分函数依赖，即</p>
<p>$staffNo\rightarrow staffName, staffAge, staffBirthDay$</p>
<p>$companyNo\rightarrow companyName, companyAge$</p>
<p>那么当我插入staff的时候我就不得不填入company相关信息</p>
<p>如果修改staff信息也不得不加上company信息</p>
<p>如果删掉了一个公司中所有的staff之后，这个公司也不存在于表格中了</p>
<p>这在现实是极其难操作甚至说是做不到的</p>
<p>以上三个分别是插入异常、修改异常和删除异常</p>
<h5 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h5><p><em>描述一个关系中属性之间的联系。例如，假设A和B均为关系R的属性，若A的每个值都和B中的一个唯一的值，则称B函数依赖于A，记为$A\rightarrow B$</em></p>
<p>在实际操作中，A为超关键字组成，且多为主键</p>
<p>函数依赖分两种，完全函数依赖与部分函数依赖</p>
<p>完全函数依赖：<em>假设A和B是某一关系的属性（组），若B函数依赖于A，但是不函数依赖于A的某一真子集，则称B完全函数依赖于A</em></p>
<p>具体表示为</p>
<p>$c_0\rightarrow c_1, c_2, c_3, …, c_n$</p>
<p>部分函数依赖：<em>如果B函数依赖于A，但是B不是完全函数依赖于A，则是B部分依赖于A</em></p>
<p>具体表示为</p>
<p>$a_0, b_0\rightarrow a_1, a_2, a_3, b_1, b_2, b_3$</p>
<p>其中$b_i$与$a_0$无关，$a_i$与$b_0$无关</p>
<p>传递依赖：<em>假设A、B、C是某一关系的属性，若$A\rightarrow B$，$B\rightarrow C$， 则称C通过B依赖传递于A</em></p>
<h4 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h4><p>主要介绍第一范式，第二范式，第三范式</p>
<p>第一范式：<em>每一行和每一列相交的位置有且仅有一个值</em></p>
<p>直接理解的话，可以看成是避免ER模型中的组合属性，将组合属性拆成多个单值属性</p>
<p>（现实中的数据库系统应该都是默认遵循第一范式的吧……）</p>
<p>第二范式：<em>满足第一范式的要求并且每个非主关键字属性都完全依赖于主关键字</em></p>
<p>就是将上述的</p>
<p>$staffNo, companyNo\rightarrow staffName, staffAge, staffBirthDay, companyName, companyAge$</p>
<p>拆成</p>
<p>$staffNo\rightarrow staffName, staffAge, staffBirthDay, companyNo$</p>
<p>$companyNo\rightarrow companyName, companyAge$</p>
<p>两张表</p>
<p>这样可以避免多个无关的实体混合在一张表中。并使它们的关系通过外键连接</p>
<p>第三范式：<em>满足第一范式和第二范式的要求并且所有非主关键字属性都不传播依赖于主属性的关系</em></p>
<p>我认为这个是将第二范式无法拆分的表中实体的关系拆分出来。</p>
<p>第二范式就是拆分直接函数依赖于主键的实体关系，但是无法拆分间接依赖于主键的实体关系，第三范式就是处理这个问题。</p>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>事务定义：<em>由单个用户或者应用程序执行的，完成读取或者更新数据库内容的一个或多个操作</em></p>
<p>事务时数据库的逻辑处理单位</p>
<p>事务的性质：</p>
<ol>
<li>原子性：一个事务就是一个原子单位</li>
<li>一致性：事务必须将数据库从一种一致的状态转化为另一种一致的状态</li>
<li>隔离性：在有并发的时候，事务的执行时相互独立的。</li>
<li>持久性：事务完成的结果要永久保存在数据库中（在外存保存）。</li>
</ol>
<p>隔离性和持久性保证了原子性和一致性</p>
<h4 id="三个问题-四个"><a href="#三个问题-四个" class="headerlink" title="三个问题(四个)"></a>三个问题(四个)</h4><h5 id="丢失更新"><a href="#丢失更新" class="headerlink" title="丢失更新"></a>丢失更新</h5><p>一个用户的更新操作被另一个用户所取代了</p>
<p><img src="/2018/06/18/数据库复习/丢失更新.png" alt="丢失更新"></p>
<h5 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h5><p>前提：允许一个事务看到另一个未提交事务的中间结果（违背隔离性）</p>
<p><img src="/2018/06/18/数据库复习/脏读.png" alt="脏读"></p>
<p>一个事务看到另一个事务在提交之前的中间结果，产生的读取数值误差</p>
<h5 id="不可重读问题"><a href="#不可重读问题" class="headerlink" title="不可重读问题"></a>不可重读问题</h5><p>在一个事务多次读取的时候另一个事务修改了数值，导致多次读取结果不一样</p>
<p><img src="/2018/06/18/数据库复习/不一致问题.png" alt="不一致问题"></p>
<h4 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h4><p>和不一致问题很像，但是是在query过程中</p>
<h4 id="可串行化"><a href="#可串行化" class="headerlink" title="可串行化"></a>可串行化</h4><p>为了保证一致性，事务使用了可串行化方法</p>
<p>可串行化中冲突操作的顺序是非常重要的：</p>
<ol>
<li>如果两个事务只读，那就没有冲突，顺序也不重要</li>
<li>如果两个事务都读且写，但是读写的是完全不相干的两个数据项，也没有冲突，顺序也不重要</li>
<li>如果一个事务写入一个数据项，另一个事务读或写相同的数据项，他们就会有冲突，顺序就很重要</li>
</ol>
<p><img src="/2018/06/18/数据库复习/序列化.png" alt="序列化"></p>
<p>当一个事务于其他事务冲突的时候，使其延迟（传统方法）</p>
<p>可串行化是DBMS默认的正确性准则（correctness criterion）</p>
<p>缺点：可串行化计算开销大，可能会做一些无用的延迟</p>
<h4 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h4><p>共享锁：事务只能读不能修改数据项的锁</p>
<p>互斥锁：事务可以读可以改数据项的锁</p>
<h5 id="2PL两段锁协议"><a href="#2PL两段锁协议" class="headerlink" title="2PL两段锁协议"></a>2PL两段锁协议</h5><p>这个锁只有两个阶段：</p>
<ol>
<li>扩展阶段：所有事务可以获取它们要的锁，但是不能释放任何锁</li>
<li>收缩阶段：所有事务可以释放它所拥有的锁，但是不能获取它们要的锁</li>
</ol>
<p>这个协议可以达到满足事务安全（解决那三个问题）的最快效率</p>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>定义大家都懂的~</p>
<h5 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h5><ol>
<li>超时</li>
</ol>
<p>设定一个极限时间，如果一个事务等待加锁的事务的等待时间超过它，则回滚此事务并重启</p>
<p>问题是：极限实践设置长了之后对解决死锁帮助不大，设置断了对长事务不友好</p>
<ol start="2">
<li>Waiting-for Graph(WFG)<br>通过WFG可以展示事务的依赖关系并且判断死锁<br>算法流程：</li>
<li>对每一个事务做一个节点</li>
<li>创造边$T_i\rightarrow T_j$如果$T_i$等待$T_j$锁住的资源</li>
<li>如果图中存在一个环，则死锁存在</li>
</ol>
<h4 id="孤立等级"><a href="#孤立等级" class="headerlink" title="孤立等级"></a>孤立等级</h4><p>由于序列化有一些缺陷，SQL允许程序员设定孤立等级</p>
<p>SQL标准中有四个孤立等级</p>
<ul>
<li>READ  UNCOMMITTED：允许脏读</li>
<li>READ COMMIT：不允许脏读</li>
<li>REPEATABLE READ：避免脏读和不可重读问题，但是无法避免幻读</li>
<li>SERIALIZABILITY：避免所有的问题</li>
</ul>
<p>注意：ORACLE只实现了SQL标准中的两个，即READ COMMITTED和 SERIALIZABLE</p>
<h4 id="数据恢复"><a href="#数据恢复" class="headerlink" title="数据恢复"></a>数据恢复</h4><p>自己看</p>

  </section>

</article>

<section class="read-more">
           
    
        
        
               
            <div class="read-more-item">
                <span class="read-more-item-dim">Older Post</span>
                <h2 class="post-list__post-title post-title"><a href="/2018/06/15/UNIX环境高级编程前部分介绍/" title="UNIX环境高级编程前部分介绍">UNIX环境高级编程前部分介绍</a></h2>
                <p class="excerpt">
                
                前言苦逼本科生要考试，考试还奇难内容齐多
这里我整理一下考试提纲
正好这也是对《unix环境高级编程》的前半部分的一个总结
就当看着乐
正文什么是操作系统？什么是UNIX操作系统？什么是Linux操作系统？它们之间的关系是怎样的？操作系统是管理和控制计算机硬件和软件资源的计算机程序，是直接运行在“裸
                &hellip;
                </p>
                <div class="post-list__meta"><time datetime="2018-06-15T13:25:02.000Z" class="post-list__meta--date date">2018-06-15</time> &#8226; <span class="post-list__meta--tags tags">于 
  <a class="tag-link" href="/tags/unix/">unix</a>, <a class="tag-link" href="/tags/课程复习/">课程复习</a>
</span><a class="btn-border-small" href="/2018/06/15/UNIX环境高级编程前部分介绍/">继续阅读</a></div>
                       
            </div>
        
     
   
   
  
</section>

  

            <footer class="footer">
    <span class="footer__copyright">
        &copy; 2018 kardel - 本站点采用 <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>
       
    </span>
    <span class="footer__copyright">
             - 基于 <a href="http://hexo.io">Hexo</a> 搭建，使用 <a href="https://github.com/monniya/hexo-theme-new-vno ">new-vno</a> 主题，由<a href="https://monniya.com ">@Monniya</a> 修改自 <a href="https://github.com/lenbo-ma/hexo-theme-vno" target="_blank">Vno</a>, 原创出自<a href="http://github.com/onevcat/vno" target="_blank">onevcat</a>
         </span>
       
    
  
         <script type="text/x-mathjax-config">
    MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
        tex2jax: { inlineMath: [ ["$", "$"], ["\\(","\\)"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno",skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']},
        TeX: {  noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } }, Macros: { href: "{}" } },
        messageStyle: "none"
    }); 
    
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
   
</footer>


        </div>
    </div>

     
<script>
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	ga('create', 'UA-78918255-1', 'auto');
	ga('send', 'pageview');
</script>

    
    <script>
        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?9cdad07c755fa23f6aced510c6760e87";
            var s = document.getElementsByTagName("script")[0]; 
            s.parentNode.insertBefore(hm, s);
        })();
    </script>



    <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
    
</body>
</html>
